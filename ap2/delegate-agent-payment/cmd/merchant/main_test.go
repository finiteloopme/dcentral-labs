// This package contains tests for the merchant server.
package main

import (
	"encoding/json"
	"fmt"
	"math/big"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"testing"

	"delegated-agent-demo/pkg/signing"
	"delegated-agent-demo/pkg/types"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Test constants
const (
	// testMerchantPK is a dummy private key for the merchant in tests.
	// This key is used to sign the cart and verify the signature.
	testMerchantPK = "0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a"
	// testTokenAddress is a dummy address for the USDC token contract.
	testTokenAddress = "0x2279B7A0a67DB372996a5FaB50D91eAA73d2eBe6"
	// testVerifyingContract is the address of the PaymentFacilitator contract that verifies the EIP-712 signatures.
	testVerifyingContract = "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512"
)

// setupTestEnv creates a temporary directory with all the necessary config and data
// files needed for the merchant handler to operate successfully. This includes:
// - A contracts.json file with the addresses of the deployed contracts.
// - A task.json file with the user's intent.
// - A config.toml file with the merchant's configuration.
// It also changes the working directory to the temporary directory, so that the
// config file can be loaded correctly.
// It returns a cleanup function that restores the original working directory and
// removes the temporary directory.
func setupTestEnv(t *testing.T) (cleanup func()) {
	tempDir, err := os.MkdirTemp("", "merchant-test-*")
	require.NoError(t, err)

	// Get the address for the test private key.
	pk, err := crypto.HexToECDSA(testMerchantPK[2:])
	require.NoError(t, err)
	merchantAddr := crypto.PubkeyToAddress(pk.PublicKey)

	// Create dummy contract and task files.
	contractsFile := filepath.Join(tempDir, "contracts.json")
	contractsData := fmt.Sprintf(`{"token_usdc": "%s", "payment_facilitator": "%s"}`,
		testTokenAddress, testVerifyingContract)
	require.NoError(t, os.WriteFile(contractsFile, []byte(contractsData), 0644))

	taskFile := filepath.Join(tempDir, "task.json")
	taskData := fmt.Sprintf(`{"mandate": {"proxyContract": "%s"}}`, testVerifyingContract)
	require.NoError(t, os.WriteFile(taskFile, []byte(taskData), 0644))

	// Create a config.toml that points to the temp files.
	configFile := filepath.Join(tempDir, "config.toml")
	configData := fmt.Sprintf(`
chainID = 31337
contractsFile = "%s"
taskFile = "%s"
merchantAddress = "%s"
MERCHANT_PRIVATE_KEY = "%s"
`, contractsFile, taskFile, merchantAddr.Hex(), testMerchantPK[2:])
	require.NoError(t, os.WriteFile(configFile, []byte(configData), 0644))

	// Temporarily change the working directory so LoadConfig finds the file.
	originalWD, err := os.Getwd()
	require.NoError(t, err)
	require.NoError(t, os.Chdir(tempDir))

	// Return a cleanup function to restore the state.
	return func() {
		require.NoError(t, os.Chdir(originalWD))
		os.RemoveAll(tempDir)
	}
}

// TestCartHandler_Success verifies the happy path for the cart handler.
// It sets up a test environment, starts a test server, and makes a request to the
// /cart endpoint. It then verifies that the response is successful and that the
// signature of the cart is valid.
// This is an integration test that ensures that all the components of the merchant
// server work together correctly.
func TestCartHandler_Success(t *testing.T) {
	cleanup := setupTestEnv(t)
	defer cleanup()

	// 1. Start a real server on a random port.
	server := httptest.NewServer(http.HandlerFunc(cartHandler))
	defer server.Close()

	// 2. Make a real HTTP request to the test server, like the agent.
	resp, err := http.Get(server.URL + "/cart")
	require.NoError(t, err, "HTTP request to test server should succeed")
	defer resp.Body.Close()

	// 3. Assert the response and decode it, just like the agent.
	assert.Equal(t, http.StatusOK, resp.StatusCode, "handler should return 200 OK")

	var signedCart types.SignedCart
	err = json.NewDecoder(resp.Body).Decode(&signedCart)
	require.NoError(t, err, "response should be valid SignedCart JSON")

	// 4. Verify the cart contents.
	pk, _ := crypto.HexToECDSA(testMerchantPK[2:])
	merchantAddr := crypto.PubkeyToAddress(pk.PublicKey)

	assert.Equal(t, merchantAddr, signedCart.Cart.Merchant, "merchant address should match test key")
	assert.Equal(t, common.HexToAddress(testTokenAddress), signedCart.Cart.Token, "token address should match test data")
	assert.Equal(t, new(big.Int).Mul(big.NewInt(49), big.NewInt(1e18)), signedCart.Cart.Amount, "amount should be the default 49")

	// 5. Verify the signature.
	// This is the most important part of the test. It ensures that the signature
	// generated by the merchant server is valid and can be verified by the agent.
	typedData, err := signing.GetCartTypedData(signedCart.Cart, common.HexToAddress(testVerifyingContract), big.NewInt(31337))
	require.NoError(t, err)

	domainSeparator, err := typedData.HashStruct("EIP712Domain", typedData.Domain.Map())
	require.NoError(t, err)
	typedDataHash, err := typedData.HashStruct(typedData.PrimaryType, typedData.Message)
	require.NoError(t, err)

	hashToSign := crypto.Keccak256(append(append([]byte{0x19, 0x01}, domainSeparator[:]...), typedDataHash[:]...))

	// Adjust V value and recover public key.
	sig := make([]byte, len(signedCart.Signature))
	copy(sig, signedCart.Signature)
	if sig[64] >= 27 {
		sig[64] -= 27
	}

	recoveredPub, err := crypto.SigToPub(hashToSign, sig)
	require.NoError(t, err)

	assert.Equal(t, pk.PublicKey, *recoveredPub, "recovered public key must match the merchant's public key")
	t.Log("Successfully verified the EIP-712 signature from the handler.")
}

// TestCartHandler_Error verifies that the cart handler returns a proper JSON error
// when a dependency (like the config file) is missing.
// This test ensures that the server fails gracefully and provides a meaningful error
// message to the client.
func TestCartHandler_Error(t *testing.T) {
	// 1. Setup: Ensure no config file exists by running in a clean directory.
	tempDir, err := os.MkdirTemp("", "merchant-err-test-*")
	require.NoError(t, err)
	defer os.RemoveAll(tempDir)

	originalWD, err := os.Getwd()
	require.NoError(t, err)
	require.NoError(t, os.Chdir(tempDir))
	defer func() { _ = os.Chdir(originalWD) }()

	// 2. Create a request and response recorder.
	req := httptest.NewRequest("GET", "/cart", nil)
	rr := httptest.NewRecorder()

	// 3. Call the handler.
	http.HandlerFunc(cartHandler).ServeHTTP(rr, req)

	// 4. Assert the status code.
	assert.Equal(t, http.StatusInternalServerError, rr.Code, "handler should return 500 internal server error")

	// 5. Assert the response body is a valid JSON error.
	var jsonResponse map[string]string
	err = json.Unmarshal(rr.Body.Bytes(), &jsonResponse)
	require.NoError(t, err, "response should be valid JSON")

	_, ok := jsonResponse["error"]
	assert.True(t, ok, "JSON response should contain an 'error' key")
	t.Logf("Received expected JSON error: %s", rr.Body.String())
}
