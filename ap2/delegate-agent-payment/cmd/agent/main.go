// This package contains the agent execution script.
// This script simulates the actions an autonomous agent or facilitator would take
// to execute a payment on behalf of a user, using the user's pre-approved intent.
package main

import (
	"context"
	"encoding/json"
	"log"
	"math/big"
	"os"
	"time"

	"delegated-agent-demo/pkg/chain"
	"delegated-agent-demo/pkg/chain/bindings"
	"delegated-agent-demo/pkg/config"
	"delegated-agent-demo/pkg/types"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
)

// main is the entry point for the agent execution script.
func main() {
	log.Println("--- (PHASE 2) AGENT EXECUTION STARTING ---")
	log.Println("...User is now 'asleep'...")

	// 1. Load configuration from config.toml and environment variables.
	cfg, err := config.LoadConfig()
	if err != nil {
		log.Fatalf("Failed to load configuration: %%v", err)
	}

	// 2. Load the artifacts generated by the user setup script.
	// This includes the deployed contract addresses and the user's signed task data.
	log.Println("Loading contract addresses and task data...")
	contracts := loadJSON[types.DeployedContracts](cfg.ContractsFile)
	task := loadJSON[types.TaskData](cfg.TaskFile)

	log.Printf("Loaded Proxy: %%s", contracts.AgentProxy.Hex())
	log.Printf("Loaded Task: %%s", task.Mandate.Task)

	// 3. Connect to the blockchain as the AGENT (facilitator).
	// It uses the agent's private key, as the agent will pay the gas for the final transaction.
	ctx := context.Background()
	agentCfg := chain.Config{
		RPCUrl:     cfg.RPCUrl,
		PrivateKey: cfg.AgentPrivateKey,
		ChainID:    big.NewInt(cfg.ChainID),
	}
	client, agentAuth, err := chain.GetClientAndAuth(ctx, agentCfg)
	if err != nil {
		log.Fatalf("Failed to connect as agent: %%v", err)
	}

	// 4. Get a contract instance for the user's AgentProxy contract.
	proxyContract, err := bindings.NewAgent(contracts.AgentProxy, client)
	if err != nil {
		log.Fatalf("Failed to instantiate proxy contract: %%v", err)
	}

	// 5. Simulate a monitoring period.
	// In a real-world scenario, the agent would be monitoring for a specific event,
	// such as a price drop, an item coming back in stock, etc.
	log.Println("Monitoring for price drop...")
	time.Sleep(3 * time.Second)
	log.Println("...PRICE DROP DETECTED! Found item for 49 USDC.")

	// 6. Create the CartMandate (the "bill" to be paid).
	// The price (49 USDC) must be less than or equal to the maxPrice in the user's intent (50 USDC).
	cartAmount := new(big.Int).Mul(big.NewInt(49), big.NewInt(1e18))

	// We must use the Go structs generated by `abigen` for the contract call.
	cart := bindings.AgentProxyCartMandate{
		Merchant: common.HexToAddress(cfg.MerchantAddress),
		Token:    contracts.TokenUSDC,
		Amount:   cartAmount,
	}

	// The `Task` field in the binding is `[32]byte`, so we must hash the string.
	intent := bindings.AgentProxyIntentMandate{
		Task:          crypto.Keccak256Hash([]byte(task.Mandate.Task)),
		Token:         task.Mandate.Token,
		MaxPrice:      task.Mandate.MaxPrice,
		Expires:       task.Mandate.Expires,
		ProxyContract: task.Mandate.ProxyContract,
		Nonce:         task.Mandate.Nonce,
	}

	// 7. Execute the purchase by calling the `executePurchase` function on the proxy.
	// The AGENT pays the gas for this transaction, but the funds are transferred
	// from the user's wallet via the proxy contract's allowance.
	intentJSON, _ := json.MarshalIndent(struct {
		Task          string
		Token         common.Address
		MaxPrice      *big.Int
		Expires       *big.Int
		ProxyContract common.Address
		Nonce         *big.Int
	}{
		Task:          task.Mandate.Task,
		Token:         intent.Token,
		MaxPrice:      intent.MaxPrice,
		Expires:       intent.Expires,
		ProxyContract: intent.ProxyContract,
		Nonce:         intent.Nonce,
	}, "", "  ")
	cartJSON, _ := json.MarshalIndent(cart, "", "  ")
	log.Printf("Intent: %%s", string(intentJSON))
	log.Printf("Cart: %%s", string(cartJSON))
	log.Println("Agent is executing purchase on user's behalf...")
	tx, err := proxyContract.ExecutePurchase(agentAuth, intent, cart, task.Signature)
	if err != nil {
		if tx != nil {
			log.Printf("Transaction hash: %%s", tx.Hash().Hex())
		}
		log.Fatalf("Failed to execute purchase: %%v", err)
	}

	// Wait for the transaction to be mined.
	receipt, err := bind.WaitMined(ctx, client, tx)
	if err != nil {
		log.Fatalf("Failed to wait for execution tx: %%v", err)
	}

	// Check the transaction receipt status.
	if receipt.Status == 0 {
		log.Fatalf("Transaction failed (reverted)!")
	}

	log.Printf("...Purchase successful! Tx: %%s", receipt.TxHash.Hex())
	log.Printf("Merchant (%%s) has been paid 49 tUSDC.", cfg.MerchantAddress)
	log.Println("--- (PHASE 2) AGENT EXECUTION COMPLETE ---")
}

// loadJSON is a generic helper utility to read a JSON file and unmarshal it into a given struct type.
func loadJSON[T any](filePath string) T {
	var data T
	file, err := os.ReadFile(filePath)
	if err != nil {
		log.Fatalf("Failed to read JSON file %%s: %%v", filePath, err)
	}
	if err := json.Unmarshal(file, &data); err != nil {
		log.Fatalf("Failed to unmarshal JSON from %%s: %%v", filePath, err)
	}
	return data
}