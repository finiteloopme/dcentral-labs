import { type PrivateStateId, type VerifierKey, type PrivateState, type Contract, type ImpureCircuitId } from '@midnight-ntwrk/midnight-js-types';
import { type ContractAddress, type ContractState, type SigningKey } from '@midnight-ntwrk/compact-runtime';
import { type CircuitCallTxInterface, type CircuitMaintenanceTxInterfaces, type ContractMaintenanceTxInterface } from './tx-interfaces';
import type { FinalizedDeployTxDataBase } from './tx-model';
import { type ContractProviders } from './contract-providers';
/**
 * Checks that two verifier keys are equal. Does initial length check match for efficiency.
 *
 * @param a First verifier key.
 * @param b Second verifier key.
 */
export declare const verifierKeysEqual: (a: Uint8Array, b: Uint8Array) => boolean;
/**
 * Checks that the given `contractState` contains the given `verifierKeys`.
 *
 * @param verifierKeys The verifier keys the client has for the deployed contract we're checking.
 * @param contractState The (typically already deployed) contract state containing verifier keys.
 *
 * @throws ContractTypeError When one or more of the local and deployed verifier keys do not match.
 */
export declare const verifyContractState: (verifierKeys: [ImpureCircuitId, VerifierKey][], contractState: ContractState) => void;
/**
 * Base type for the configuration options for {@link findDeployedContract}.
 */
export type FindDeployedContractOptionsBase<C extends Contract> = {
    /**
     * The contract to use to execute circuits.
     */
    readonly contract: C;
    /**
     * The address of a previously deployed contract.
     */
    readonly contractAddress: ContractAddress;
    /**
     * The signing key to use to perform contract maintenance updates. If defined, the given signing
     * key is stored for this contract address. This is useful when someone has already added the given signing
     * key to the contract maintenance authority. If undefined, and there is an existing signing key for the
     * contract address locally, the existing signing key is kept. This is useful when the contract was
     * deployed locally. If undefined, and there is not an existing signing key for the contract address
     * locally, a fresh signing key is generated and stored for the contract address locally. This is
     * useful when you want to give a signing key to someone else to add you as a maintenance authority.
     */
    readonly signingKey?: SigningKey;
};
/**
 * {@link findDeployedContract} base configuration that includes an initial private
 * state to store and the private state ID at which to store it. Only used if
 * the intention is to overwrite the private state currently stored at the given
 * private state ID.
 */
export type FindDeployedContractOptionsExistingPrivateState<C extends Contract> = FindDeployedContractOptionsBase<C> & {
    /**
     * An identifier for the private state of the contract being found.
     */
    readonly privateStateId: PrivateStateId;
};
/**
 * {@link findDeployedContract} configuration that includes an initial private
 * state to store and the private state ID at which to store it. Only used if
 * the intention is to overwrite the private state currently stored at the given
 * private state ID.
 */
export type FindDeployedContractOptionsStorePrivateState<C extends Contract> = FindDeployedContractOptionsExistingPrivateState<C> & {
    /**
     * For types of contract that make no use of private state and or witnesses that operate upon it, this
     * property may be `undefined`. Otherwise, the value provided via this property should be same initial
     * state that was used when calling {@link deployContract}.
     */
    readonly initialPrivateState: PrivateState<C>;
};
/**
 * Configuration for {@link findDeployedContract}.
 */
export type FindDeployedContractOptions<C extends Contract> = FindDeployedContractOptionsBase<C> | FindDeployedContractOptionsExistingPrivateState<C> | FindDeployedContractOptionsStorePrivateState<C>;
/**
 * Base type for a deployed contract that has been found on the blockchain.
 */
export type FoundContract<C extends Contract> = {
    /**
     * Data for the finalized deploy transaction corresponding to this contract.
     */
    readonly deployTxData: FinalizedDeployTxDataBase<C>;
    /**
     * Interface for creating call transactions for a contract.
     */
    readonly callTx: CircuitCallTxInterface<C>;
    /**
     * An interface for creating maintenance transactions for circuits defined in the
     * contract that was deployed.
     */
    readonly circuitMaintenanceTx: CircuitMaintenanceTxInterfaces<C>;
    /**
     * Interface for creating maintenance transactions for the contract that was
     * deployed.
     */
    readonly contractMaintenanceTx: ContractMaintenanceTxInterface;
};
export declare function findDeployedContract<C extends Contract<undefined>>(providers: ContractProviders<C, ImpureCircuitId<C>, unknown>, options: FindDeployedContractOptionsBase<C>): Promise<FoundContract<C>>;
export declare function findDeployedContract<C extends Contract>(providers: ContractProviders<C>, options: FindDeployedContractOptionsExistingPrivateState<C>): Promise<FoundContract<C>>;
export declare function findDeployedContract<C extends Contract>(providers: ContractProviders<C>, options: FindDeployedContractOptionsStorePrivateState<C>): Promise<FoundContract<C>>;
//# sourceMappingURL=find-deployed-contract.d.ts.map