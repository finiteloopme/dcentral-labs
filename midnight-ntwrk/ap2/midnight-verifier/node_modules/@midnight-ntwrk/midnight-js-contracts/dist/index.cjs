'use strict';

var compactRuntime = require('@midnight-ntwrk/compact-runtime');
var midnightJsTypes = require('@midnight-ntwrk/midnight-js-types');
var midnightJsUtils = require('@midnight-ntwrk/midnight-js-utils');
var midnightJsNetworkId = require('@midnight-ntwrk/midnight-js-network-id');
var ledger = require('@midnight-ntwrk/ledger');

/**
 * An error indicating that a transaction submitted to a consensus node failed.
 */
class TxFailedError extends Error {
    finalizedTxData;
    circuitId;
    /**
     * @param finalizedTxData The finalization data of the transaction that failed.
     * @param circuitId The name of the circuit that was called to create the call
     *                  transaction that failed. Only defined if a call transaction
     *                  failed.
     */
    constructor(finalizedTxData, circuitId) {
        super('Transaction failed');
        this.finalizedTxData = finalizedTxData;
        this.circuitId = circuitId;
        this.message = JSON.stringify({
            ...(circuitId && { circuitId }),
            ...finalizedTxData
        }, null, '\t');
    }
}
/**
 * An error indicating that a deploy transaction was not successfully applied by the consensus node.
 */
class DeployTxFailedError extends TxFailedError {
    /**
     * @param finalizedTxData The finalization data of the deployment transaction that failed.
     */
    constructor(finalizedTxData) {
        super(finalizedTxData);
        this.name = 'DeployTxFailedError';
    }
}
/**
 * An error indicating that a call transaction was not successfully applied by the consensus node.
 */
class CallTxFailedError extends TxFailedError {
    /**
     * @param finalizedTxData The finalization data of the call transaction that failed.
     * @param circuitId The name of the circuit that was called to build the transaction.
     */
    constructor(finalizedTxData, circuitId) {
        super(finalizedTxData, circuitId);
        this.name = 'CallTxFailedError';
    }
}
/**
 * The error that is thrown when there is a contract type mismatch between a given contract type,
 * and the initial state that is deployed at a given contract address.
 *
 * @remarks
 * This error is typically thrown during calls to {@link findDeployedContract} where the supplied contract
 * address represents a different type of contract to the contract type given.
 */
class ContractTypeError extends TypeError {
    contractState;
    circuitIds;
    /**
     * Initializes a new {@link ContractTypeError}.
     *
     * @param contractState The initial deployed contract state.
     * @param circuitIds The circuits that are undefined, or have a verifier key mismatch with the
     *                   key present in `contractState`.
     */
    constructor(contractState, circuitIds) {
        super(`Following operations: ${circuitIds.join(', ')}, are undefined or have mismatched verifier keys for contract state ${contractState.toString(false)}`);
        this.contractState = contractState;
        this.circuitIds = circuitIds;
    }
}
/**
 * An error indicating that a contract maintenance authority replacement transaction failed.
 */
class ReplaceMaintenanceAuthorityTxFailedError extends TxFailedError {
    constructor(finalizedTxData) {
        super(finalizedTxData);
        this.name = 'ReplaceMaintenanceAuthorityTxFailedError';
    }
}
/**
 * An error indicating that a verifier key removal transaction failed.
 */
class RemoveVerifierKeyTxFailedError extends TxFailedError {
    constructor(finalizedTxData) {
        super(finalizedTxData);
        this.name = 'RemoveVerifierKeyTxFailedError';
    }
}
/**
 * An error indicating that a verifier key insertion transaction failed.
 */
class InsertVerifierKeyTxFailedError extends TxFailedError {
    constructor(finalizedTxData) {
        super(finalizedTxData);
        this.name = 'InsertVerifierKeyTxFailedError';
    }
}
/**
 * An error indicating that a private state ID was specified for a call transaction while a private
 * state provider was not. We want to let the user know so that they aren't under the impression the
 * private state of a contract was updated when it wasn't.
 */
class IncompleteCallTxPrivateStateConfig extends Error {
    constructor() {
        super('Incorrect call transaction configuration');
        this.message =
            "'privateStateId' was defined for call transaction while 'privateStateProvider' was undefined";
    }
}
/**
 * An error indicating that an initial private state was specified for a contract find while a
 * private state ID was not. We can't store the initial private state if we don't have a private state ID,
 * and we need to let the user know that.
 */
class IncompleteFindContractPrivateStateConfig extends Error {
    constructor() {
        super('Incorrect find contract configuration');
        this.message =
            "'initialPrivateState' was defined for contract find while 'privateStateId' was undefined";
    }
}

/**
 * Fetches only the public visible (Zswap and ledger) states of a contract.
 *
 * @param publicDataProvider The provider to use to fetch the public states (Zswap and ledger)
 *                           from the blockchain.
 * @param contractAddress The ledger address of the contract.
 */
const getPublicStates = async (publicDataProvider, contractAddress) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    const zswapAndContractState = await publicDataProvider.queryZSwapAndContractState(contractAddress);
    midnightJsUtils.assertDefined(zswapAndContractState, `No public state found at contract address '${contractAddress}'`);
    const [zswapChainState, contractState] = zswapAndContractState;
    return { contractState, zswapChainState };
};
/**
 * Retrieves the Zswap, ledger, and private states of the contract corresponding
 * to the given identifier using the given providers.
 *
 * @param publicDataProvider The provider to use to fetch the public states (Zswap and ledger)
 *                           from the blockchain.
 * @param privateStateProvider The provider to use to fetch the private state.
 * @param contractAddress The ledger address of the contract.
 * @param privateStateId The identifier for the private state of the contract.
 */
const getStates = async (publicDataProvider, privateStateProvider, contractAddress, privateStateId) => {
    const publicContractStates = await getPublicStates(publicDataProvider, contractAddress);
    const privateState = await privateStateProvider.get(privateStateId);
    midnightJsUtils.assertDefined(privateState, `No private state found at private state ID '${privateStateId}'`);
    return { ...publicContractStates, privateState };
};

// A default segment number to use when creating inputs and outputs. The Ledger has exposed this parameter
// now but we don't know what the value should be, and assume that everything first in segment '0'. This
// will change with work on Unshielded Tokens and I believe the Ledger will come with utility that will inform
// the segment numbers.
const DEFAULT_SEGMENT_NUMBER = 0;
const checkKeys = (coinInfo) => Object.keys(coinInfo).forEach((key) => {
    if (key !== 'value' && key !== 'type' && key !== 'nonce') {
        throw new TypeError(`Key '${key}' should not be present in output data ${coinInfo}`);
    }
});
const serializeCoinInfo = (coinInfo) => {
    checkKeys(coinInfo);
    return JSON.stringify({
        ...coinInfo,
        value: { __big_int_val__: coinInfo.value.toString() }
    });
};
const serializeQualifiedCoinInfo = (coinInfo) => {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars, camelcase
    const { mt_index, ...rest } = coinInfo;
    return serializeCoinInfo(rest);
};
const deserializeCoinInfo = (coinInfo) => {
    const res = JSON.parse(coinInfo, (key, value) => {
        if (key === 'value' &&
            value != null &&
            typeof value === 'object' &&
            '__big_int_val__' in value &&
            // eslint-disable-next-line no-underscore-dangle
            typeof value.__big_int_val__ === 'string') {
            // eslint-disable-next-line no-underscore-dangle
            return BigInt(value.__big_int_val__);
        }
        if ((key === 'color' || key === 'nonce') &&
            value != null &&
            typeof value === 'object' &&
            '__uint8Array_val__' in value &&
            // eslint-disable-next-line no-underscore-dangle
            typeof value.__uint8Array_val__ === 'string') {
            // eslint-disable-next-line no-underscore-dangle
            return midnightJsUtils.fromHex(value.__uint8Array_val__);
        }
        return value;
    });
    checkKeys(res);
    return res;
};
const createUnprovenOutput = ({ coinInfo, recipient }, encryptionPublicKey, segmentNumber = 0) => 
// TBD need to confirm segment number and wallet encryptionPublicKey usage.
recipient.is_left
    ? ledger.UnprovenOutput.new(coinInfo, segmentNumber, recipient.left, encryptionPublicKey)
    : ledger.UnprovenOutput.newContractOwned(coinInfo, segmentNumber, recipient.right);
const unprovenOfferFromCoinInfo = ([coinInfo, unproven], f) => {
    const { type, value } = deserializeCoinInfo(coinInfo);
    return f(unproven, type, value);
};
const unprovenOfferFromMap = (map, f) => Array.from(map)
    .map((coinInfo) => unprovenOfferFromCoinInfo(coinInfo, f))
    .reduce((acc, curr) => acc.merge(curr), new ledger.UnprovenOffer());
const zswapStateToOffer = (zswapLocalState, encryptionPublicKey, params) => {
    const unprovenOutputs = new Map(zswapLocalState.outputs.map((output) => [
        serializeCoinInfo(output.coinInfo),
        createUnprovenOutput(output, encryptionPublicKey, DEFAULT_SEGMENT_NUMBER)
    ]));
    const unprovenInputs = new Map();
    const unprovenTransients = new Map();
    zswapLocalState.inputs.forEach((qualifiedCoinInfo) => {
        const serializedCoinInfo = serializeQualifiedCoinInfo(qualifiedCoinInfo);
        const unprovenOutput = unprovenOutputs.get(serializedCoinInfo);
        if (unprovenOutput) {
            unprovenTransients.set(serializedCoinInfo, ledger.UnprovenTransient.newFromContractOwnedOutput(qualifiedCoinInfo, DEFAULT_SEGMENT_NUMBER, unprovenOutput));
            unprovenOutputs.delete(serializedCoinInfo);
        }
        else {
            midnightJsUtils.assertDefined(params, `Only outputs or transients are expected when no chain state is provided`);
            midnightJsUtils.assertIsContractAddress(params.contractAddress);
            unprovenInputs.set(serializedCoinInfo, ledger.UnprovenInput.newContractOwned(qualifiedCoinInfo, DEFAULT_SEGMENT_NUMBER, params.contractAddress, params.zswapChainState));
        }
    });
    return unprovenOfferFromMap(unprovenInputs, ledger.UnprovenOffer.fromInput)
        .merge(unprovenOfferFromMap(unprovenOutputs, ledger.UnprovenOffer.fromOutput))
        .merge(unprovenOfferFromMap(unprovenTransients, ledger.UnprovenOffer.fromTransient));
};
const zswapStateToNewCoins = (receiverCoinPublicKey, zswapState) => zswapState.outputs
    .filter((output) => output.recipient.left === receiverCoinPublicKey)
    .map(({ coinInfo }) => coinInfo);
const encryptionPublicKeyForzswapState = (zswapState, walletCoinPublicKey, walletEncryptionPublicKey) => {
    const walletCoinPublickKey = midnightJsUtils.parseCoinPublicKeyToHex(walletCoinPublicKey, midnightJsNetworkId.getZswapNetworkId());
    const localCoinPublicKey = midnightJsUtils.parseCoinPublicKeyToHex(zswapState.coinPublicKey, midnightJsNetworkId.getZswapNetworkId());
    if (localCoinPublicKey !== walletCoinPublickKey) {
        throw new Error('Unable to lookup encryption public key (Unsupported coin)');
    }
    return midnightJsUtils.parseEncPublicKeyToHex(walletEncryptionPublicKey, midnightJsNetworkId.getZswapNetworkId());
};

const toLedgerContractState = (contractState) => ledger.ContractState.deserialize(contractState.serialize(midnightJsNetworkId.getRuntimeNetworkId()), midnightJsNetworkId.getLedgerNetworkId());
const fromLedgerContractState = (contractState) => compactRuntime.ContractState.deserialize(contractState.serialize(midnightJsNetworkId.getLedgerNetworkId()), midnightJsNetworkId.getRuntimeNetworkId());
const toLedgerQueryContext = (queryContext) => new ledger.QueryContext(ledger.StateValue.decode(queryContext.state.encode()), queryContext.address);
const addVerifierKeys = (verifierKeys, contractState) => {
    verifierKeys.forEach(([impureCircuitId, verifierKey]) => {
        const operation = contractState.operation(impureCircuitId);
        midnightJsUtils.assertDefined(operation, `Circuit '${impureCircuitId}' is undefined for contract state ${contractState.toString(false)}`);
        // TODO: Remove mutability
        operation.verifierKey = verifierKey;
        contractState.setOperation(impureCircuitId, operation);
    });
};
const contractMaintenanceAuthority = (sk, contractState) => {
    const svk = compactRuntime.signatureVerifyingKey(sk);
    const threshold = 1;
    return new ledger.ContractMaintenanceAuthority([svk], threshold, contractState ? contractState.maintenanceAuthority.counter + 1n : 0n);
};
const addMaintenanceAuthority = (sk, contractState) => {
    // eslint-disable-next-line no-param-reassign
    contractState.maintenanceAuthority = contractMaintenanceAuthority(sk);
};
const createUnprovenLedgerDeployTx = (verifierKeys, sk, contractState, zswapLocalState, encryptionPublicKey) => {
    const ledgerContractState = toLedgerContractState(contractState);
    addVerifierKeys(verifierKeys, ledgerContractState);
    addMaintenanceAuthority(sk, ledgerContractState);
    const contractDeploy = new ledger.ContractDeploy(ledgerContractState);
    return [
        contractDeploy.address,
        fromLedgerContractState(contractDeploy.initialState),
        new midnightJsTypes.UnprovenTransaction(zswapStateToOffer(zswapLocalState, encryptionPublicKey), undefined, new ledger.ContractCallsPrototype().addDeploy(contractDeploy))
    ];
};
const createUnprovenLedgerCallTx = (circuitId, contractAddress, initialContractState, zswapChainState, partitionedTranscript, privateTranscriptOutputs, input, output, nextZswapLocalState, encryptionPublicKey) => {
    const op = toLedgerContractState(initialContractState).operation(circuitId);
    midnightJsUtils.assertDefined(op, `Operation '${circuitId}' is undefined for contract state ${initialContractState.toString(false)}`);
    return new midnightJsTypes.UnprovenTransaction(zswapStateToOffer(nextZswapLocalState, encryptionPublicKey, {
        contractAddress,
        zswapChainState
    }), undefined, new ledger.ContractCallsPrototype().addCall(new ledger.ContractCallPrototype(contractAddress, circuitId, op, partitionedTranscript[0], partitionedTranscript[1], privateTranscriptOutputs, input, output, ledger.communicationCommitmentRandomness(), circuitId)));
};
// Utilities for creating single contract updates.
const replaceAuthority = (newAuthority, contractState) => new ledger.ReplaceAuthority(contractMaintenanceAuthority(newAuthority, contractState));
const removeVerifierKey = (operation) => new ledger.VerifierKeyRemove(operation, new ledger.ContractOperationVersion('v2'));
const insertVerifierKey = (operation, newVk) => new ledger.VerifierKeyInsert(operation, new ledger.ContractOperationVersionedVerifierKey('v2', newVk));
// Utilities for unproven transactions for the single contract updates above.
const unprovenTxFromContractUpdates = (contractAddress, updates, contractState, sk) => {
    const maintenanceUpdate = new ledger.MaintenanceUpdate(contractAddress, updates, contractState.maintenanceAuthority.counter);
    // 'idx' is '0n' because Midnight.js currently only supports single-party maintenance update authorities
    const idx = 0n;
    const signedMaintenanceUpdate = maintenanceUpdate.addSignature(idx, ledger.signData(sk, maintenanceUpdate.dataToSign));
    return new midnightJsTypes.UnprovenTransaction(new ledger.UnprovenOffer(), undefined, new ledger.ContractCallsPrototype().addMaintenanceUpdate(signedMaintenanceUpdate));
};
const createUnprovenReplaceAuthorityTx = (contractAddress, newAuthority, contractState, currentAuthority) => unprovenTxFromContractUpdates(contractAddress, [replaceAuthority(newAuthority, contractState)], contractState, currentAuthority);
const createUnprovenRemoveVerifierKeyTx = (contractAddress, operation, contractState, currentAuthority) => unprovenTxFromContractUpdates(contractAddress, [removeVerifierKey(operation)], contractState, currentAuthority);
const createUnprovenInsertVerifierKeyTx = (contractAddress, operation, newVk, contractState, currentAuthority) => unprovenTxFromContractUpdates(contractAddress, [insertVerifierKey(operation, newVk)], contractState, currentAuthority);

const partitionTranscript = (initialTxContext, finalTxContext, publicTranscript) => {
    const partitionedTranscripts = ledger.partitionTranscripts([
        new ledger.PreTranscript(Array.from(finalTxContext.comIndicies).reduce((queryContext, entry) => queryContext.insertCommitment(...entry), toLedgerQueryContext(initialTxContext)), publicTranscript)
    ], ledger.LedgerParameters.dummyParameters());
    if (partitionedTranscripts.length !== 1) {
        throw new Error(`Expected one transcript partition pair, received: ${partitionedTranscripts.length}`);
    }
    return partitionedTranscripts[0];
};
/**
 * Calls a circuit in the given contract according to the given configuration.
 *
 * @param options Configuration.
 */
const call = (options) => {
    const { contract, circuitId, contractAddress, coinPublicKey, initialContractState } = options;
    const circuit = contract.impureCircuits[circuitId];
    midnightJsUtils.assertDefined(circuit, `Circuit '${circuitId}' is not defined`);
    const initialTxContext = new compactRuntime.QueryContext(initialContractState.data, contractAddress);
    const { result, context, proofData } = circuit({
        originalState: initialContractState,
        currentPrivateState: 'initialPrivateState' in options ? options.initialPrivateState : undefined,
        transactionContext: initialTxContext,
        currentZswapLocalState: compactRuntime.emptyZswapLocalState(midnightJsUtils.parseCoinPublicKeyToHex(coinPublicKey, midnightJsNetworkId.getZswapNetworkId()))
    }, ...('args' in options ? options.args : []));
    return {
        public: {
            nextContractState: context.transactionContext.state,
            publicTranscript: proofData.publicTranscript,
            partitionedTranscript: partitionTranscript(initialTxContext, context.transactionContext, proofData.publicTranscript)
        },
        private: {
            result,
            input: proofData.input,
            output: proofData.output,
            privateTranscriptOutputs: proofData.privateTranscriptOutputs,
            nextPrivateState: context.currentPrivateState,
            nextZswapLocalState: compactRuntime.decodeZswapLocalState(context.currentZswapLocalState)
        }
    };
};

/**
 * Calls a circuit using the provided initial `states` and creates an unbalanced,
 * unproven, unsubmitted, call transaction.
 *
 * @param options Configuration.
 *
 * @returns Data produced by the circuit call and an unproven transaction assembled from the call result.
 */
function createUnprovenCallTxFromInitialStates(options, walletCoinPublicKey, walletEncryptionPublicKey) {
    const { contract, circuitId, contractAddress, coinPublicKey, initialContractState, initialZswapChainState } = options;
    midnightJsUtils.assertIsContractAddress(contractAddress);
    midnightJsUtils.assertDefined(contract.impureCircuits[circuitId], `Circuit '${circuitId}' is undefined`);
    const callResult = call(options);
    return {
        public: {
            ...callResult.public
        },
        private: {
            ...callResult.private,
            unprovenTx: createUnprovenLedgerCallTx(circuitId, contractAddress, initialContractState, initialZswapChainState, callResult.public.partitionedTranscript, callResult.private.privateTranscriptOutputs, callResult.private.input, callResult.private.output, callResult.private.nextZswapLocalState, encryptionPublicKeyForzswapState(callResult.private.nextZswapLocalState, walletCoinPublicKey, walletEncryptionPublicKey)),
            newCoins: zswapStateToNewCoins(midnightJsUtils.parseCoinPublicKeyToHex(coinPublicKey, midnightJsNetworkId.getZswapNetworkId()), callResult.private.nextZswapLocalState)
        }
    };
}
const createCallOptions = (callTxOptions, coinPublicKey, initialContractState, initialZswapChainState, initialPrivateState) => {
    const callOptionsBase = {
        contract: callTxOptions.contract,
        contractAddress: callTxOptions.contractAddress,
        circuitId: callTxOptions.circuitId
    };
    const callOptionsWithArguments = 'args' in callTxOptions
        ? {
            ...callOptionsBase,
            args: callTxOptions.args
        }
        : callOptionsBase;
    const callOptionsBaseWithProviderDataDependencies = {
        ...callOptionsWithArguments,
        coinPublicKey: midnightJsUtils.parseCoinPublicKeyToHex(coinPublicKey, midnightJsNetworkId.getZswapNetworkId()),
        initialContractState,
        initialZswapChainState
    };
    const callOptions = initialPrivateState
        ? { ...callOptionsBaseWithProviderDataDependencies, initialPrivateState }
        : callOptionsBaseWithProviderDataDependencies;
    return callOptions;
};
/**
 * Calls a circuit using states fetched from the public data provider and private state
 * provider, then creates an unbalanced, unproven, unsubmitted, call transaction.
 *
 * @param providers The providers to use to create the call transaction.
 * @param options Configuration.
 *
 * @returns A promise that contains all data produced by the circuit call and an unproven
 *          transaction assembled from the call result.
 *
 * @throws IncompleteCallTxPrivateStateConfig If a `privateStateId` was given but a `privateStateProvider`
 *                                           was not. We assume that when a user gives a `privateStateId`,
 *                                           they want to update the private state store.
 */
async function createUnprovenCallTx(providers, options) {
    midnightJsUtils.assertIsContractAddress(options.contractAddress);
    midnightJsUtils.assertDefined(options.contract.impureCircuits[options.circuitId], `Circuit '${options.circuitId}' is undefined`);
    const hasPrivateStateProvider = 'privateStateProvider' in providers;
    const hasPrivateStateId = 'privateStateId' in options;
    if (hasPrivateStateId && !hasPrivateStateProvider) {
        throw new IncompleteCallTxPrivateStateConfig();
    }
    if (hasPrivateStateId && hasPrivateStateProvider) {
        const { zswapChainState, contractState, privateState } = await getStates(providers.publicDataProvider, providers.privateStateProvider, options.contractAddress, options.privateStateId);
        return createUnprovenCallTxFromInitialStates(createCallOptions(options, midnightJsUtils.parseCoinPublicKeyToHex(providers.walletProvider.coinPublicKey, midnightJsNetworkId.getZswapNetworkId()), contractState, zswapChainState, privateState), providers.walletProvider.coinPublicKey, providers.walletProvider.encryptionPublicKey);
    }
    const { zswapChainState, contractState } = await getPublicStates(providers.publicDataProvider, options.contractAddress);
    return createUnprovenCallTxFromInitialStates(createCallOptions(options, midnightJsUtils.parseCoinPublicKeyToHex(providers.walletProvider.coinPublicKey, midnightJsNetworkId.getZswapNetworkId()), contractState, zswapChainState), providers.walletProvider.coinPublicKey, providers.walletProvider.encryptionPublicKey);
}

/**
 * Proves, balances, and submits an unproven deployment or call transaction using
 * the given providers, according to the given options.
 *
 * @param providers The providers used to manage the transaction lifecycle.
 * @param options Configuration.
 *
 * @returns A promise that resolves with the finalized transaction data for the invocation,
 *          or rejects if an error occurs along the way.
 */
const submitTx = async (providers, options) => {
    const proveTxConfig = options.circuitId
        ? { zkConfig: await providers.zkConfigProvider.get(options.circuitId) }
        : undefined;
    const unbalancedTx = await providers.proofProvider.proveTx(options.unprovenTx, proveTxConfig);
    const balancedTx = await providers.walletProvider.balanceTx(unbalancedTx, options.newCoins ?? []);
    const txId = await providers.midnightProvider.submitTx(balancedTx);
    const finalizedTxData = await providers.publicDataProvider.watchForTxData(txId);
    return finalizedTxData;
};

/**
 * Creates and submits a transaction for the invocation of a circuit on a given contract.
 *
 * @param providers The providers used to manage the invocation lifecycle.
 * @param options Configuration.
 *
 * @returns A `Promise` that resolves with the finalized transaction data for the invocation of
 *         `circuitId` on `contract` with the given `args`; or rejects with an error if the invocation fails.
 */
async function submitCallTx(providers, options) {
    midnightJsUtils.assertIsContractAddress(options.contractAddress);
    midnightJsUtils.assertDefined(options.contract.impureCircuits[options.circuitId], `Circuit '${options.circuitId}' is undefined`);
    const hasPrivateStateProvider = 'privateStateProvider' in providers;
    const hasPrivateStateId = 'privateStateId' in options;
    if (hasPrivateStateId && !hasPrivateStateProvider) {
        throw new IncompleteCallTxPrivateStateConfig();
    }
    const unprovenCallTxData = await createUnprovenCallTx(providers, options);
    const finalizedTxData = await submitTx(providers, {
        unprovenTx: unprovenCallTxData.private.unprovenTx,
        newCoins: unprovenCallTxData.private.newCoins,
        circuitId: options.circuitId
    });
    if (finalizedTxData.status !== midnightJsTypes.SucceedEntirely) {
        throw new CallTxFailedError(finalizedTxData, options.circuitId);
    }
    if (hasPrivateStateId && hasPrivateStateProvider) {
        await providers.privateStateProvider.set(options.privateStateId, unprovenCallTxData.private.nextPrivateState);
    }
    return {
        private: unprovenCallTxData.private,
        public: {
            ...unprovenCallTxData.public,
            ...finalizedTxData
        }
    };
}

/**
 * Constructs and submits a transaction that replaces the maintenance
 * authority stored on the blockchain for this contract. After the transaction is
 * finalized, the current signing key stored in the given private state provider
 * is overwritten with the given new authority key.
 *
 * @param providers The providers to use to manage the transaction lifecycle.
 * @param contractAddress The address of the contract for which the maintenance
 *                        authority should be updated.
 *
 * TODO: There are at least three options we should support in the future:
 *       1. Replace authority and maintain key (current).
 *       2. Replace authority and do not maintain key.
 *       3. Add additional authorities and maintain original key.
 */
const submitReplaceAuthorityTx = (providers, contractAddress) => 
/**
 * @param newAuthority The signing key of the new contract maintenance authority.
 *
 * @returns A promise that resolves with the finalized transaction data, or rejects if
 *          an error occurs along the way.
 */
async (newAuthority) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    const contractState = await providers.publicDataProvider.queryContractState(contractAddress);
    midnightJsUtils.assertDefined(contractState, `No contract state found on chain for contract address '${contractAddress}'`);
    const currentAuthority = await providers.privateStateProvider.getSigningKey(contractAddress);
    midnightJsUtils.assertDefined(currentAuthority, `Signing key for contract address '${contractAddress}' not found`);
    const unprovenTx = createUnprovenReplaceAuthorityTx(contractAddress, newAuthority, contractState, currentAuthority);
    const submitTxResult = await submitTx(providers, { unprovenTx });
    if (submitTxResult.status !== midnightJsTypes.SucceedEntirely) {
        throw new ReplaceMaintenanceAuthorityTxFailedError(submitTxResult);
    }
    // TODO: What if machine crashes right before the following set executes? How to recover?
    //       Likely will need a history of pending transactions.
    await providers.privateStateProvider.setSigningKey(contractAddress, newAuthority);
    return submitTxResult;
};

/**
 * Constructs and submits a transaction that adds a new verifier key to the
 * blockchain for the given circuit ID at the given contract address.
 *
 * @param providers The providers to use to manage the transaction lifecycle.
 * @param contractAddress The address of the contract containing the circuit for which
 *                        the verifier key should be inserted.
 * @param circuitId The circuit for which the verifier key should be inserted.
 * @param newVk The new verifier key for the circuit.
 *
 * @returns A promise that resolves with the finalized transaction data, or rejects if
 *          an error occurs along the way.
 *
 * TODO: We'll likely want to modify ZKConfigProvider provider so that the verifier keys are
 *       automatically rotated in this function. This likely involves storing key versions
 *       along with keys in ZKConfigProvider. By default, artifacts for the latest version
 *       would be fetched to build transactions.
 */
const submitInsertVerifierKeyTx = async (providers, contractAddress, circuitId, newVk) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    const contractState = await providers.publicDataProvider.queryContractState(contractAddress);
    midnightJsUtils.assertDefined(contractState, `No contract state found on chain for contract address '${contractAddress}'`);
    midnightJsUtils.assertUndefined(contractState.operation(circuitId), `Circuit '${circuitId}' is already defined for contract at address '${contractAddress}'`);
    const signingKey = await providers.privateStateProvider.getSigningKey(contractAddress);
    midnightJsUtils.assertDefined(signingKey, `Signing key for contract address '${contractAddress}' not found`);
    const unprovenTx = createUnprovenInsertVerifierKeyTx(contractAddress, circuitId, newVk, contractState, signingKey);
    const submitTxResult = await submitTx(providers, { unprovenTx });
    if (submitTxResult.status !== midnightJsTypes.SucceedEntirely) {
        throw new InsertVerifierKeyTxFailedError(submitTxResult);
    }
    return submitTxResult;
};

/**
 * Constructs and submits a transaction that removes the current verifier key stored
 * on the blockchain for the given circuit ID at the given contract address.
 *
 * @param providers The providers to use to manage the transaction lifecycle.
 * @param contractAddress The address of the contract containing the circuit for which
 *                        the verifier key should be removed.
 * @param circuitId The circuit for which the verifier key should be removed.
 *
 * @returns A promise that resolves with the finalized transaction data, or rejects if
 *          an error occurs along the way.
 *
 * TODO: We'll likely want to modify ZKConfigProvider provider so that the verifier keys are
 *       automatically rotated in this function. This likely involves storing key versions
 *       along with keys in ZKConfigProvider. By default, artifacts for the latest version
 *       would be fetched to build transactions.
 */
const submitRemoveVerifierKeyTx = async (providers, contractAddress, circuitId) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    const contractState = await providers.publicDataProvider.queryContractState(contractAddress);
    midnightJsUtils.assertDefined(contractState, `No contract state found on chain for contract address '${contractAddress}'`);
    midnightJsUtils.assertDefined(contractState.operation(circuitId), `Circuit '${circuitId}' not found for contract at address '${contractAddress}'`);
    const signingKey = await providers.privateStateProvider.getSigningKey(contractAddress);
    midnightJsUtils.assertDefined(signingKey, `Signing key for contract address '${contractAddress}' not found`);
    const unprovenTx = createUnprovenRemoveVerifierKeyTx(contractAddress, circuitId, contractState, signingKey);
    const submitTxResult = await submitTx(providers, { unprovenTx });
    if (submitTxResult.status !== midnightJsTypes.SucceedEntirely) {
        throw new RemoveVerifierKeyTxFailedError(submitTxResult);
    }
    return submitTxResult;
};

/**
 * Creates a {@link CallTxOptions} object from various data.
 */
const createCallTxOptions = (contract, circuitId, contractAddress, privateStateId, args) => {
    const callOptionsBase = {
        contract,
        circuitId,
        contractAddress
    };
    const callTxOptionsBase = args.length !== 0 ? { ...callOptionsBase, args } : callOptionsBase;
    const callTxOptions = privateStateId
        ? { ...callTxOptionsBase, privateStateId }
        : callTxOptionsBase;
    return callTxOptions;
};
/**
 * Creates a circuit call transaction interface for a contract.
 *
 * @param providers The providers to use to build transactions.
 * @param contract The contract to use to execute circuits.
 * @param contractAddress The ledger address of the contract.
 * @param privateStateId The identifier of the state of the witnesses of the contract.
 */
const createCircuitCallTxInterface = (providers, contract, contractAddress, privateStateId) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    return midnightJsTypes.getImpureCircuitIds(contract).reduce((acc, circuitId) => ({
        ...acc,
        [circuitId]: (...args) => submitCallTx(providers, createCallTxOptions(contract, circuitId, contractAddress, privateStateId, args))
    }), {});
};
/**
 * Creates a {@link CircuitMaintenanceTxInterface}.
 *
 * @param providers The providers to use to create and submit transactions.
 * @param circuitId The circuit ID the interface is for.
 * @param contractAddress The address of the deployed contract for which this
 *                        interface is being created.
 */
const createCircuitMaintenanceTxInterface = (providers, circuitId, contractAddress) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    return {
        removeVerifierKey() {
            return submitRemoveVerifierKeyTx(providers, contractAddress, circuitId);
        },
        insertVerifierKey(newVk) {
            return submitInsertVerifierKeyTx(providers, contractAddress, circuitId, newVk);
        }
    };
};
/**
 * Creates a {@link CircuitMaintenanceTxInterfaces}.
 *
 * @param providers The providers to use to build transactions.
 * @param contract The contract to use to execute circuits.
 * @param contractAddress The ledger address of the contract.
 */
const createCircuitMaintenanceTxInterfaces = (providers, contract, contractAddress) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    return midnightJsTypes.getImpureCircuitIds(contract).reduce((acc, circuitId) => ({
        ...acc,
        [circuitId]: createCircuitMaintenanceTxInterface(providers, circuitId, contractAddress)
    }), {});
};
/**
 * Creates a {@link ContractMaintenanceTxInterface}.
 *
 * @param providers The providers to use to build transactions.
 * @param contractAddress The ledger address of the contract.
 */
const createContractMaintenanceTxInterface = (providers, contractAddress) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    return {
        replaceAuthority: submitReplaceAuthorityTx(providers, contractAddress)
    };
};

/**
 * Calls the constructor of the given contract according to the given configuration.
 *
 * @param options Configuration.
 */
const callContractConstructor = (options) => {
    const constructorResult = options.contract.initialState(compactRuntime.constructorContext('initialPrivateState' in options ? options.initialPrivateState : undefined, midnightJsUtils.parseCoinPublicKeyToHex(options.coinPublicKey, midnightJsNetworkId.getZswapNetworkId())), ...('args' in options ? options.args : []));
    return {
        nextContractState: constructorResult.currentContractState,
        nextPrivateState: constructorResult.currentPrivateState,
        nextZswapLocalState: compactRuntime.decodeZswapLocalState(constructorResult.currentZswapLocalState)
    };
};

const createContractConstructorOptions = (deployTxOptions, coinPublicKey) => {
    const constructorOptionsBase = {
        contract: deployTxOptions.contract
    };
    const constructorOptionsWithArguments = 'args' in deployTxOptions
        ? {
            ...constructorOptionsBase,
            args: deployTxOptions.args
        }
        : constructorOptionsBase;
    const constructorOptionsWithProviderDataDependencies = {
        ...constructorOptionsWithArguments,
        coinPublicKey
    };
    const constructorOptions = 'initialPrivateState' in deployTxOptions
        ? {
            ...constructorOptionsWithProviderDataDependencies,
            initialPrivateState: deployTxOptions.initialPrivateState
        }
        : constructorOptionsWithProviderDataDependencies;
    return constructorOptions;
};
/**
 * Calls a contract constructor and creates an unbalanced, unproven, unsubmitted, deploy transaction
 * from the constructor results.
 *
 * @param verifierKeys The verifier keys for the contract being deployed.
 * @param coinPublicKey The Zswap coin public key of the current user.
 * @param options Configuration.
 *
 * @returns Data produced by the contract constructor call and an unproven deployment transaction
 *          assembled from the contract constructor result.
 */
function createUnprovenDeployTxFromVerifierKeys(verifierKeys, coinPublicKey, options, encryptionPublicKey) {
    const { nextContractState, nextPrivateState, nextZswapLocalState } = callContractConstructor(createContractConstructorOptions(options, coinPublicKey));
    const [contractAddress, initialContractState, unprovenTx] = createUnprovenLedgerDeployTx(verifierKeys, options.signingKey, nextContractState, nextZswapLocalState, encryptionPublicKey);
    return {
        public: {
            contractAddress,
            initialContractState
        },
        private: {
            signingKey: options.signingKey,
            initialPrivateState: nextPrivateState,
            initialZswapState: nextZswapLocalState,
            unprovenTx,
            newCoins: zswapStateToNewCoins(coinPublicKey, nextZswapLocalState)
        }
    };
}
/**
 * Calls a contract constructor and creates an unbalanced, unproven, unsubmitted, deploy transaction
 * from the constructor results.
 *
 * @param providers The providers to use to create the deploy transaction.
 * @param options Configuration.
 *
 * @returns A promise that contains all data produced by the constructor call and an unproven
 *          transaction assembled from the constructor result.
 */
async function createUnprovenDeployTx(providers, options) {
    const verifierKeys = await providers.zkConfigProvider.getVerifierKeys(midnightJsTypes.getImpureCircuitIds(options.contract));
    return createUnprovenDeployTxFromVerifierKeys(verifierKeys, midnightJsUtils.parseCoinPublicKeyToHex(providers.walletProvider.coinPublicKey, midnightJsNetworkId.getZswapNetworkId()), options, providers.walletProvider.encryptionPublicKey);
}

/**
 * Creates and submits a deploy transaction for the given contract.
 *
 * @param providers The providers used to manage the deploy lifecycle.
 * @param options Configuration.
 *
 * @returns A `Promise` that resolves with the finalized deployment transaction data;
 *          or rejects with an error if the deployment fails.
 */
async function submitDeployTx(providers, options) {
    const unprovenDeployTxData = await createUnprovenDeployTx(providers, options);
    const finalizedTxData = await submitTx(providers, {
        unprovenTx: unprovenDeployTxData.private.unprovenTx,
        newCoins: unprovenDeployTxData.private.newCoins
    });
    if (finalizedTxData.status !== midnightJsTypes.SucceedEntirely) {
        throw new DeployTxFailedError(finalizedTxData);
    }
    if ('privateStateId' in options) {
        await providers.privateStateProvider.set(options.privateStateId, unprovenDeployTxData.private.initialPrivateState);
    }
    await providers.privateStateProvider.setSigningKey(unprovenDeployTxData.public.contractAddress, unprovenDeployTxData.private.signingKey);
    return {
        private: unprovenDeployTxData.private,
        public: {
            ...finalizedTxData,
            ...unprovenDeployTxData.public
        }
    };
}

const createDeployTxOptions = (deployContractOptions) => {
    const deployTxOptionsBase = {
        ...deployContractOptions,
        signingKey: deployContractOptions.signingKey ?? compactRuntime.sampleSigningKey()
    };
    const deployTxOptions = 'privateStateId' in deployContractOptions
        ? {
            ...deployTxOptionsBase,
            privateStateId: deployContractOptions.privateStateId,
            initialPrivateState: deployContractOptions.initialPrivateState
        }
        : deployTxOptionsBase;
    return deployTxOptions;
};
/**
 * Creates and submits a contract deployment transaction. This function is the entry point for the transaction
 * construction workflow and is used to create a {@link DeployedContract} instance.
 *
 * @param providers The providers used to manage the transaction lifecycle.
 * @param options Configuration.
 *
 * @throws DeployTxFailedError If the transaction is submitted successfully but produces an error
 *                             when executed by the node.
 */
async function deployContract(providers, options) {
    const deployTxData = await submitDeployTx(providers, createDeployTxOptions(options));
    return {
        deployTxData,
        callTx: createCircuitCallTxInterface(providers, options.contract, deployTxData.public.contractAddress, 'privateStateId' in options ? options.privateStateId : undefined),
        circuitMaintenanceTx: createCircuitMaintenanceTxInterfaces(providers, options.contract, deployTxData.public.contractAddress),
        contractMaintenanceTx: createContractMaintenanceTxInterface(providers, deployTxData.public.contractAddress)
    };
}

const setOrGetInitialSigningKey = async (privateStateProvider, options) => {
    if (options.signingKey) {
        await privateStateProvider.setSigningKey(options.contractAddress, options.signingKey);
        return options.signingKey;
    }
    const existingSigningKey = await privateStateProvider.getSigningKey(options.contractAddress);
    if (existingSigningKey) {
        return existingSigningKey;
    }
    const freshSigningKey = compactRuntime.sampleSigningKey();
    await privateStateProvider.setSigningKey(options.contractAddress, freshSigningKey);
    return freshSigningKey;
};
const setOrGetInitialPrivateState = async (privateStateProvider, options) => {
    /**
     * If both 'privateStateId' and 'initialPrivateState' are defined,
     * then 'initialPrivateState' is stored in private state provider at 'privateStateId'.
     *
     * If 'privateStateId' is defined and 'initialPrivateState' is undefined,
     * and the private state provider has an entry at 'privateStateId',
     * then the find reports the stored private state as the initialPrivateState.
     *
     * If 'privateStateId' is defined and 'initialPrivateState' is undefined,
     * and the private state provider does not have an entry at 'privateStateId',
     * then an error is returned.
     *
     * If 'privateStateId' is undefined and 'initialPrivateState' is defined,
     * then an error is returned.
     *
     * If 'privateStateId' is undefined and 'initialPrivateState' is undefined,
     * then no private state is stored.
     */
    const hasPrivateStateId = 'privateStateId' in options;
    const hasInitialPrivateState = 'initialPrivateState' in options;
    if (hasPrivateStateId) {
        if (hasInitialPrivateState) {
            await privateStateProvider.set(options.privateStateId, options.initialPrivateState);
            return options.initialPrivateState;
        }
        const currentPrivateState = await privateStateProvider.get(options.privateStateId);
        midnightJsUtils.assertDefined(currentPrivateState, `No private state found at private state ID '${options.privateStateId}'`);
        return currentPrivateState;
    }
    if (hasInitialPrivateState) {
        throw new IncompleteFindContractPrivateStateConfig();
    }
    // Cast to 'PrivateState<C>' because if we've reached this point, the private state of
    // the contract should be 'undefined'.
    return undefined;
};
/**
 * Checks that two verifier keys are equal. Does initial length check match for efficiency.
 *
 * @param a First verifier key.
 * @param b Second verifier key.
 */
const verifierKeysEqual = (a, b) => a.length === b.length && midnightJsUtils.toHex(a) === midnightJsUtils.toHex(b);
/**
 * Checks that the given `contractState` contains the given `verifierKeys`.
 *
 * @param verifierKeys The verifier keys the client has for the deployed contract we're checking.
 * @param contractState The (typically already deployed) contract state containing verifier keys.
 *
 * @throws ContractTypeError When one or more of the local and deployed verifier keys do not match.
 */
const verifyContractState = (verifierKeys, contractState) => {
    const mismatchedCircuitIds = verifierKeys.reduce((acc, [circuitId, localVk]) => !contractState.operation(circuitId) ||
        !verifierKeysEqual(localVk, contractState.operation(circuitId).verifierKey)
        ? [...acc, circuitId]
        : acc, []);
    if (mismatchedCircuitIds.length > 0) {
        throw new ContractTypeError(contractState, mismatchedCircuitIds);
    }
};
/**
 * Creates an instance of {@link FoundContract} given the address of a deployed contract and an
 * optional private state ID at which an existing private state is stored. When given, the current value
 * at the private state ID is used as the `initialPrivateState` value in the `finalizedDeployTxData`
 * property of the returned `FoundContract`.
 *
 * @param providers The providers used to manage transaction lifecycles.
 * @param options Configuration.
 *
 * @throws Error Improper `privateStateId` and `initialPrivateState` configuration.
 * @throws Error No contract state could be found at `contractAddress`.
 * @throws TypeError Thrown if `contractAddress` is not correctly formatted as a contract address.
 * @throws ContractTypeError One or more circuits defined on `contract` are undefined on the contract
 *                           state found at `contractAddress`, or have mis-matched verifier keys.
 * @throws IncompleteFindContractPrivateStateConfig If an `initialPrivateState` is given but no
 *                                                  `privateStateId` is given to store it under.
 */
async function findDeployedContract(providers, options) {
    const { contract, contractAddress } = options;
    midnightJsUtils.assertIsContractAddress(contractAddress);
    const finalizedTxData = await providers.publicDataProvider.watchForDeployTxData(contractAddress);
    const initialContractState = await providers.publicDataProvider.queryDeployContractState(contractAddress);
    midnightJsUtils.assertDefined(initialContractState, `No contract deployed at contract address '${contractAddress}'`);
    const currentContractState = await providers.publicDataProvider.queryContractState(contractAddress);
    midnightJsUtils.assertDefined(currentContractState, `No contract deployed at contract address '${contractAddress}'`);
    const verifierKeys = await providers.zkConfigProvider.getVerifierKeys(midnightJsTypes.getImpureCircuitIds(contract));
    verifyContractState(verifierKeys, currentContractState);
    const signingKey = await setOrGetInitialSigningKey(providers.privateStateProvider, options);
    const initialPrivateState = await setOrGetInitialPrivateState(providers.privateStateProvider, options);
    return {
        deployTxData: {
            private: {
                signingKey,
                initialPrivateState
            },
            public: {
                ...finalizedTxData,
                contractAddress,
                initialContractState
            }
        },
        callTx: createCircuitCallTxInterface(providers, contract, contractAddress, 'privateStateId' in options ? options.privateStateId : undefined),
        circuitMaintenanceTx: createCircuitMaintenanceTxInterfaces(providers, contract, contractAddress),
        contractMaintenanceTx: createContractMaintenanceTxInterface(providers, contractAddress)
    };
}

exports.CallTxFailedError = CallTxFailedError;
exports.ContractTypeError = ContractTypeError;
exports.DeployTxFailedError = DeployTxFailedError;
exports.IncompleteCallTxPrivateStateConfig = IncompleteCallTxPrivateStateConfig;
exports.IncompleteFindContractPrivateStateConfig = IncompleteFindContractPrivateStateConfig;
exports.InsertVerifierKeyTxFailedError = InsertVerifierKeyTxFailedError;
exports.RemoveVerifierKeyTxFailedError = RemoveVerifierKeyTxFailedError;
exports.ReplaceMaintenanceAuthorityTxFailedError = ReplaceMaintenanceAuthorityTxFailedError;
exports.TxFailedError = TxFailedError;
exports.call = call;
exports.callContractConstructor = callContractConstructor;
exports.createCallTxOptions = createCallTxOptions;
exports.createCircuitCallTxInterface = createCircuitCallTxInterface;
exports.createCircuitMaintenanceTxInterface = createCircuitMaintenanceTxInterface;
exports.createCircuitMaintenanceTxInterfaces = createCircuitMaintenanceTxInterfaces;
exports.createContractMaintenanceTxInterface = createContractMaintenanceTxInterface;
exports.createUnprovenCallTx = createUnprovenCallTx;
exports.createUnprovenCallTxFromInitialStates = createUnprovenCallTxFromInitialStates;
exports.createUnprovenDeployTx = createUnprovenDeployTx;
exports.createUnprovenDeployTxFromVerifierKeys = createUnprovenDeployTxFromVerifierKeys;
exports.deployContract = deployContract;
exports.findDeployedContract = findDeployedContract;
exports.getPublicStates = getPublicStates;
exports.getStates = getStates;
exports.submitCallTx = submitCallTx;
exports.submitDeployTx = submitDeployTx;
exports.submitInsertVerifierKeyTx = submitInsertVerifierKeyTx;
exports.submitRemoveVerifierKeyTx = submitRemoveVerifierKeyTx;
exports.submitReplaceAuthorityTx = submitReplaceAuthorityTx;
exports.submitTx = submitTx;
exports.verifierKeysEqual = verifierKeysEqual;
exports.verifyContractState = verifyContractState;
//# sourceMappingURL=index.cjs.map
