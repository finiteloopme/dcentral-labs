import type { FinalizedTxData, ImpureCircuitId } from '@midnight-ntwrk/midnight-js-types';
import type { ContractState } from '@midnight-ntwrk/compact-runtime';
/**
 * An error indicating that a transaction submitted to a consensus node failed.
 */
export declare class TxFailedError extends Error {
    readonly finalizedTxData: FinalizedTxData;
    readonly circuitId?: ImpureCircuitId | undefined;
    /**
     * @param finalizedTxData The finalization data of the transaction that failed.
     * @param circuitId The name of the circuit that was called to create the call
     *                  transaction that failed. Only defined if a call transaction
     *                  failed.
     */
    constructor(finalizedTxData: FinalizedTxData, circuitId?: ImpureCircuitId | undefined);
}
/**
 * An error indicating that a deploy transaction was not successfully applied by the consensus node.
 */
export declare class DeployTxFailedError extends TxFailedError {
    /**
     * @param finalizedTxData The finalization data of the deployment transaction that failed.
     */
    constructor(finalizedTxData: FinalizedTxData);
}
/**
 * An error indicating that a call transaction was not successfully applied by the consensus node.
 */
export declare class CallTxFailedError extends TxFailedError {
    /**
     * @param finalizedTxData The finalization data of the call transaction that failed.
     * @param circuitId The name of the circuit that was called to build the transaction.
     */
    constructor(finalizedTxData: FinalizedTxData, circuitId: ImpureCircuitId);
}
/**
 * The error that is thrown when there is a contract type mismatch between a given contract type,
 * and the initial state that is deployed at a given contract address.
 *
 * @remarks
 * This error is typically thrown during calls to {@link findDeployedContract} where the supplied contract
 * address represents a different type of contract to the contract type given.
 */
export declare class ContractTypeError extends TypeError {
    readonly contractState: ContractState;
    readonly circuitIds: ImpureCircuitId[];
    /**
     * Initializes a new {@link ContractTypeError}.
     *
     * @param contractState The initial deployed contract state.
     * @param circuitIds The circuits that are undefined, or have a verifier key mismatch with the
     *                   key present in `contractState`.
     */
    constructor(contractState: ContractState, circuitIds: ImpureCircuitId[]);
}
/**
 * An error indicating that a contract maintenance authority replacement transaction failed.
 */
export declare class ReplaceMaintenanceAuthorityTxFailedError extends TxFailedError {
    constructor(finalizedTxData: FinalizedTxData);
}
/**
 * An error indicating that a verifier key removal transaction failed.
 */
export declare class RemoveVerifierKeyTxFailedError extends TxFailedError {
    constructor(finalizedTxData: FinalizedTxData);
}
/**
 * An error indicating that a verifier key insertion transaction failed.
 */
export declare class InsertVerifierKeyTxFailedError extends TxFailedError {
    constructor(finalizedTxData: FinalizedTxData);
}
/**
 * An error indicating that a private state ID was specified for a call transaction while a private
 * state provider was not. We want to let the user know so that they aren't under the impression the
 * private state of a contract was updated when it wasn't.
 */
export declare class IncompleteCallTxPrivateStateConfig extends Error {
    constructor();
}
/**
 * An error indicating that an initial private state was specified for a contract find while a
 * private state ID was not. We can't store the initial private state if we don't have a private state ID,
 * and we need to let the user know that.
 */
export declare class IncompleteFindContractPrivateStateConfig extends Error {
    constructor();
}
//# sourceMappingURL=errors.d.ts.map