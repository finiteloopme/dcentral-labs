import { type NetworkId } from '@midnight-ntwrk/zswap';
/**
 * The result of parsing a string as a hex-encoded string.
 */
export type ParsedHexString = {
    /** A flag indicating if the hex-string has a `'0x'` prefix. */
    readonly hasPrefix: boolean;
    /** The captured sequence of _whole_ bytes found in the source string. */
    readonly byteChars: string;
    /** The remaining characters of incomplete bytes and/or the non hexadecimal characters found
     * in the source string. */
    readonly incompleteChars: string;
};
/**
 * Parses a string as a hex-encoded string.
 *
 * @param source The source string to parse.
 * @returns A {@link ParsedHexString} describing the parsed elements of `source`.
 *
 * @example
 * parseHex('Hello') =>
 *   {
 *     hasPrefix: false,
 *     incompleteChars: 'Hello'
 *   }
 *
 * @example
 * parseHex('ab12e') =>
 *   {
 *     hasPrefix: false,
 *     byteChars: 'ab12'
 *     incompleteChars: 'e'
 *   }
 *
 * @example
 * parseHex('0xab12') =>
 *   {
 *     hasPrefix: true,
 *     byteChars: 'ab12'
 *     incompleteChars: ''
 *   }
 */
export declare const parseHex: (source: string) => ParsedHexString;
/**
 * Converts a byte string into a hex string.
 *
 * @param bytes The byte string to encode.
 */
export declare const toHex: (bytes: Uint8Array) => string;
/**
 * Converts a hex string into a byte string.
 *
 * @param str The hex string to decode.
 */
export declare const fromHex: (str: string) => Buffer;
/**
 * Determines if a string represents a hex-encoded sequence of bytes.
 *
 * @param source The source string.
 * @param byteLen An optional number of bytes that `source` should represent. If not specified
 * then any number of bytes can be represented by `source`.
 * @returns `true` if the `source` string is parsable as a hex-string, of non-zero length, and
 * of the optional byte length of `byteLen`; otherwise `false`.
 */
export declare const isHex: (source: string, byteLen?: number) => boolean;
/**
 * Asserts that a string represents a hex-encoded sequence of bytes.
 *
 * @param source The source string.
 * @param byteLen An optional number of bytes that `source` should represent. If not specified
 * then any number of bytes can be represented by `source`.
 *
 * @throws `Error`
 * `byteLen` is \<= zero. Valid hex-strings will be required to have at least one byte.
 * @throws `TypeError`
 * `source` is not a hex-encoded string because it:
 * - is empty,
 * - contains invalid or incomplete characters, or
 * - does not represent `byteLen` bytes.
 */
export declare function assertIsHex(source: string, byteLen?: number): asserts source is NonNullable<string>;
/**
 * Parses a coin public key (in Bech32m format or hex) into a hex formatted string.
 *
 * @param possibleBech32 The input string, which can be a Bech32m-encoded coin public key or a hex string.
 * @param zswapNetworkId The network ID used for decoding the Bech32m formatted string.
 * @returns The hex string representation of the coin public key.
 *
 * @throws `Error`
 * If the input string is not a valid hex string or a valid Bech32m-encoded coin public key.
 */
export declare const parseCoinPublicKeyToHex: (possibleBech32: string, zswapNetworkId: NetworkId) => string;
/**
 * Parses an encryption public key (in Bech32m or hex format) into a hex formatted string.
 *
 * @param possibleBech32 The input string, which can be a Bech32m-encoded encryption public key or a hex string.
 * @param zswapNetworkId The network ID used for decoding the Bech32m formatted string.
 * @returns The hex string representation of the encryption public key.
 *
 * @throws `Error`
 * If the input string is not a valid hex string or a valid Bech32m-encoded encryption public key.
 */
export declare const parseEncPublicKeyToHex: (possibleBech32: string, zswapNetworkId: NetworkId) => string;
//# sourceMappingURL=hex-utils.d.ts.map