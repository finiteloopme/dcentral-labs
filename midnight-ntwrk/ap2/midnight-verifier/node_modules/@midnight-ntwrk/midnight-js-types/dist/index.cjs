'use strict';

var ledger = require('@midnight-ntwrk/ledger');

/**
 * Creates a branded prover key representation from a prover key binary.
 *
 * @param uint8Array The prover key binary.
 */
const createProverKey = (uint8Array) => {
    return uint8Array;
};
/**
 * Creates a branded verifier key representation from a verifier key binary.
 *
 * @param uint8Array The verifier key binary.
 */
const createVerifierKey = (uint8Array) => {
    return uint8Array;
};
/**
 * Creates a branded ZKIR representation from a ZKIR binary.
 *
 * @param uint8Array The ZKIR binary.
 */
const createZKIR = (uint8Array) => {
    return uint8Array;
};
/**
 * Creates an {@link UnbalancedTransaction} from a ledger transaction.
 *
 * @param tx The ledger transaction to wrap.
 */
const createUnbalancedTx = (tx) => {
    return tx;
};
/**
 * Creates an {@link BalancedTransaction} from a ledger transaction.
 * @param tx The ledger transaction to wrap.
 */
const createBalancedTx = (tx) => {
    return tx;
};
/**
 * Indicates that the transaction is invalid.
 */
const FailEntirely = 'FailEntirely';
/**
 * Indicates that the transaction is valid but the portion of the transcript
 * that is allowed to fail (the portion after a checkpoint) did fail. All effects
 * from the guaranteed part of the transaction are kept but the effects from the
 * fallible part of the transaction are discarded.
 */
const FailFallible = 'FailFallible';
/**
 * Indicates that the guaranteed and fallible portions of the transaction were
 * successful.
 */
const SucceedEntirely = 'SucceedEntirely';

/**
 * A provider for zero-knowledge intermediate representations, prover keys, and verifier keys. All
 * three are used by the {@link ProofProvider} to create a proof for a call transaction. The implementation
 * of this provider depends on the runtime environment, since each environment has different conventions
 * for accessing static artifacts.
 * @typeParam K - The type of the circuit ID used by the provider.
 */
class ZKConfigProvider {
    /**
     * Retrieves the verifier keys produced by `compactc` for the given circuits.
     * @param circuitIds The circuit IDs of the verifier keys to retrieve.
     */
    async getVerifierKeys(circuitIds) {
        return Promise.all(circuitIds.map(async (id) => {
            const key = await this.getVerifierKey(id);
            return [id, key];
        }));
    }
    /**
     * Retrieves all zero-knowledge artifacts produced by `compactc` for the given circuit.
     * @param circuitId The circuit ID of the artifacts to retrieve.
     */
    async get(circuitId) {
        return {
            circuitId,
            proverKey: await this.getProverKey(circuitId),
            verifierKey: await this.getVerifierKey(circuitId),
            zkir: await this.getZKIR(circuitId)
        };
    }
}

/**
 * An error describing an invalid protocol scheme.
 */
class InvalidProtocolSchemeError extends Error {
    invalidScheme;
    allowableSchemes;
    /**
     * @param invalidScheme The invalid scheme.
     * @param allowableSchemes The valid schemes that are allowed.
     */
    constructor(invalidScheme, allowableSchemes) {
        super(`Invalid protocol scheme: '${invalidScheme}'. Allowable schemes are one of: ${allowableSchemes.join(',')}`);
        this.invalidScheme = invalidScheme;
        this.allowableSchemes = allowableSchemes;
    }
}

/**
 * A valid named log level.
 */
exports.LogLevel = void 0;
(function (LogLevel) {
    /**
     * Log levels typically used by DAapp developers.
     */
    LogLevel["INFO"] = "info";
    LogLevel["WARN"] = "warn";
    LogLevel["ERROR"] = "error";
    LogLevel["FATAL"] = "fatal";
    /**
     * Log levels used by Midnight.JS to report internal state.
     */
    LogLevel["DEBUG"] = "debug";
    LogLevel["TRACE"] = "trace";
})(exports.LogLevel || (exports.LogLevel = {}));

/**
 * Typesafe version of `Object.keys(contract.impureCircuits)`.
 *
 * @param contract The contract having impure circuits for which we want ids.
 *
 * @typeParam C The contract type for which we would like impure circuit IDs.
 */
const getImpureCircuitIds = (contract) => Object.keys(contract.impureCircuits);

Object.defineProperty(exports, "UnprovenTransaction", {
    enumerable: true,
    get: function () { return ledger.UnprovenTransaction; }
});
exports.FailEntirely = FailEntirely;
exports.FailFallible = FailFallible;
exports.InvalidProtocolSchemeError = InvalidProtocolSchemeError;
exports.SucceedEntirely = SucceedEntirely;
exports.ZKConfigProvider = ZKConfigProvider;
exports.createBalancedTx = createBalancedTx;
exports.createProverKey = createProverKey;
exports.createUnbalancedTx = createUnbalancedTx;
exports.createVerifierKey = createVerifierKey;
exports.createZKIR = createZKIR;
exports.getImpureCircuitIds = getImpureCircuitIds;
//# sourceMappingURL=index.cjs.map
