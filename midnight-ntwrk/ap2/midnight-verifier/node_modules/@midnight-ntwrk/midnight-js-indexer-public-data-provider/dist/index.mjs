import { InvalidProtocolSchemeError, FailEntirely, FailFallible, SucceedEntirely } from '@midnight-ntwrk/midnight-js-types';
import { Transaction, ZswapChainState } from '@midnight-ntwrk/ledger';
import { ContractState } from '@midnight-ntwrk/compact-runtime';
import { ApolloClient, InMemoryCache } from '@apollo/client/core/core.cjs';
import { from, split } from '@apollo/client/link/core/core.cjs';
import { createHttpLink } from '@apollo/client/link/http/http.cjs';
import { RetryLink } from '@apollo/client/link/retry/retry.cjs';
import { getMainDefinition } from '@apollo/client/utilities/utilities.cjs';
import { GraphQLWsLink } from '@apollo/client/link/subscriptions/subscriptions.cjs';
import { Buffer } from 'buffer';
import * as Rx from 'rxjs';
import fetch from 'cross-fetch';
import { createClient } from 'graphql-ws';
import * as ws from 'isomorphic-ws';
import { assertIsContractAddress } from '@midnight-ntwrk/midnight-js-utils';
import { networkIdToHex, getNetworkId, getLedgerNetworkId, getRuntimeNetworkId } from '@midnight-ntwrk/midnight-js-network-id';

const BlockHashQueryDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "BLOCK_HASH_QUERY" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "offset" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "BlockOffset" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "block" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "offset" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "offset" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "height" } }, { "kind": "Field", "name": { "kind": "Name", "value": "hash" } }] } }] } }] };
const TxIdQueryDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "TX_ID_QUERY" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "offset" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "TransactionOffset" } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "transactions" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "offset" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "offset" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "raw" } }, { "kind": "Field", "name": { "kind": "Name", "value": "applyStage" } }, { "kind": "Field", "name": { "kind": "Name", "value": "hash" } }, { "kind": "Field", "name": { "kind": "Name", "value": "block" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "height" } }, { "kind": "Field", "name": { "kind": "Name", "value": "hash" } }] } }] } }] } }] };
const DeployTxQueryDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "DEPLOY_TX_QUERY" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "address" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "HexEncoded" } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "contractAction" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "address" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "address" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "ContractDeploy" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "transaction" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "raw" } }, { "kind": "Field", "name": { "kind": "Name", "value": "applyStage" } }, { "kind": "Field", "name": { "kind": "Name", "value": "hash" } }, { "kind": "Field", "name": { "kind": "Name", "value": "identifiers" } }, { "kind": "Field", "name": { "kind": "Name", "value": "contractActions" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "address" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "block" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "height" } }, { "kind": "Field", "name": { "kind": "Name", "value": "hash" } }] } }] } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "ContractUpdate" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "transaction" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "raw" } }, { "kind": "Field", "name": { "kind": "Name", "value": "applyStage" } }, { "kind": "Field", "name": { "kind": "Name", "value": "hash" } }, { "kind": "Field", "name": { "kind": "Name", "value": "identifiers" } }, { "kind": "Field", "name": { "kind": "Name", "value": "contractActions" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "address" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "block" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "height" } }, { "kind": "Field", "name": { "kind": "Name", "value": "hash" } }] } }] } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "ContractCall" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "deploy" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "transaction" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "raw" } }, { "kind": "Field", "name": { "kind": "Name", "value": "applyStage" } }, { "kind": "Field", "name": { "kind": "Name", "value": "hash" } }, { "kind": "Field", "name": { "kind": "Name", "value": "identifiers" } }, { "kind": "Field", "name": { "kind": "Name", "value": "contractActions" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "address" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "block" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "height" } }, { "kind": "Field", "name": { "kind": "Name", "value": "hash" } }] } }] } }] } }] } }] } }] } }] };
const DeployContractStateTxQueryDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "DEPLOY_CONTRACT_STATE_TX_QUERY" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "address" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "HexEncoded" } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "contractAction" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "address" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "address" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "ContractDeploy" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "state" } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "ContractUpdate" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "state" } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "ContractCall" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "deploy" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "transaction" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "contractActions" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "address" } }, { "kind": "Field", "name": { "kind": "Name", "value": "state" } }] } }] } }] } }] } }] } }] } }] };
const LatestContractTxBlockHeightQueryDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "LATEST_CONTRACT_TX_BLOCK_HEIGHT_QUERY" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "address" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "HexEncoded" } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "contractAction" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "address" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "address" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "transaction" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "block" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "height" } }] } }] } }] } }] } }] };
const TxsFromBlockSubDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "subscription", "name": { "kind": "Name", "value": "TXS_FROM_BLOCK_SUB" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "offset" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "BlockOffset" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "blocks" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "offset" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "offset" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "hash" } }, { "kind": "Field", "name": { "kind": "Name", "value": "height" } }, { "kind": "Field", "name": { "kind": "Name", "value": "transactions" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "hash" } }, { "kind": "Field", "name": { "kind": "Name", "value": "identifiers" } }, { "kind": "Field", "name": { "kind": "Name", "value": "contractActions" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "state" } }, { "kind": "Field", "name": { "kind": "Name", "value": "address" } }] } }] } }] } }] } }] };
const ContractStateQueryDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "CONTRACT_STATE_QUERY" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "address" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "HexEncoded" } } } }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "offset" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ContractActionOffset" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "contractAction" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "address" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "address" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "offset" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "offset" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "state" } }] } }] } }] };
const ContractStateSubDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "subscription", "name": { "kind": "Name", "value": "CONTRACT_STATE_SUB" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "address" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "HexEncoded" } } } }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "offset" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "BlockOffset" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "contractActions" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "address" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "address" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "offset" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "offset" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "state" } }] } }] } }] };
const BothStateQueryDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "BOTH_STATE_QUERY" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "address" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "HexEncoded" } } } }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "offset" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ContractActionOffset" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "contractAction" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "address" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "address" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "offset" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "offset" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "state" } }, { "kind": "Field", "name": { "kind": "Name", "value": "chainState" } }] } }] } }] };

/* eslint-disable */
const documents = {
    "\n  query BLOCK_HASH_QUERY($offset: BlockOffset) {\n    block(offset: $offset) {\n      height\n      hash\n    }\n  }": BlockHashQueryDocument,
    "\n  query TX_ID_QUERY($offset: TransactionOffset!) {\n    transactions(offset: $offset) {\n      raw\n      applyStage\n      hash\n      block {\n        height\n        hash\n      }\n    }\n  }": TxIdQueryDocument,
    "\n  query DEPLOY_TX_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      ... on ContractDeploy {\n        transaction {\n\t        raw\n          applyStage\n          hash\n          identifiers\n          contractActions {\n            address\n          }\n          block {\n            height\n            hash\n          }\n        }\n      }\n      ... on ContractUpdate {\n        transaction {\n\t        raw\n          applyStage\n          hash\n          identifiers\n          contractActions {\n            address\n          }\n          block {\n            height\n            hash\n          }\n        }\n      }\n      ... on ContractCall {\n        deploy {\n          transaction {\n\t          raw\n            applyStage\n            hash\n            identifiers\n            contractActions {\n              address\n            }\n            block {\n              height\n              hash\n            }\n          }\n        }\n      }\n    }\n  }": DeployTxQueryDocument,
    "\n  query DEPLOY_CONTRACT_STATE_TX_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      ... on ContractDeploy {\n        state\n      }\n      ... on ContractUpdate {\n        state\n      }\n      ... on ContractCall {\n        deploy {\n          transaction {\n            contractActions {\n              address\n              state\n            }\n          }\n        }\n      }\n    }\n  }": DeployContractStateTxQueryDocument,
    "\n  query LATEST_CONTRACT_TX_BLOCK_HEIGHT_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      transaction {\n        block {\n          height\n        }\n      }\n    }\n  }": LatestContractTxBlockHeightQueryDocument,
    "\n  subscription TXS_FROM_BLOCK_SUB($offset: BlockOffset) {\n    blocks(offset: $offset) {\n      hash,\n      height,\n      transactions {\n        hash\n        identifiers\n        contractActions {\n          state\n          address\n        }\n      }\n    }\n  }": TxsFromBlockSubDocument,
    "\n  query CONTRACT_STATE_QUERY($address: HexEncoded!, $offset: ContractActionOffset) {\n    contractAction(address: $address, offset: $offset) {\n      state\n    }\n  }": ContractStateQueryDocument,
    "\n  subscription CONTRACT_STATE_SUB($address: HexEncoded!, $offset: BlockOffset) {\n    contractActions(address: $address, offset: $offset) {\n      state\n    }\n  }": ContractStateSubDocument,
    "\n  query BOTH_STATE_QUERY($address: HexEncoded!, $offset: ContractActionOffset) {\n    contractAction(address: $address, offset: $offset) {\n      state\n      chainState\n    }\n  }": BothStateQueryDocument,
};
function gql(source) {
    return documents[source] ?? {};
}

const BLOCK_QUERY = gql(`
  query BLOCK_HASH_QUERY($offset: BlockOffset) {
    block(offset: $offset) {
      height
      hash
    }
  }`);
const TX_ID_QUERY = gql(`
  query TX_ID_QUERY($offset: TransactionOffset!) {
    transactions(offset: $offset) {
      raw
      applyStage
      hash
      block {
        height
        hash
      }
    }
  }`);
const DEPLOY_TX_QUERY = gql(`
  query DEPLOY_TX_QUERY($address: HexEncoded!) {
    contractAction(address: $address) {
      ... on ContractDeploy {
        transaction {
	        raw
          applyStage
          hash
          identifiers
          contractActions {
            address
          }
          block {
            height
            hash
          }
        }
      }
      ... on ContractUpdate {
        transaction {
	        raw
          applyStage
          hash
          identifiers
          contractActions {
            address
          }
          block {
            height
            hash
          }
        }
      }
      ... on ContractCall {
        deploy {
          transaction {
	          raw
            applyStage
            hash
            identifiers
            contractActions {
              address
            }
            block {
              height
              hash
            }
          }
        }
      }
    }
  }`);
const DEPLOY_CONTRACT_STATE_TX_QUERY = gql(`
  query DEPLOY_CONTRACT_STATE_TX_QUERY($address: HexEncoded!) {
    contractAction(address: $address) {
      ... on ContractDeploy {
        state
      }
      ... on ContractUpdate {
        state
      }
      ... on ContractCall {
        deploy {
          transaction {
            contractActions {
              address
              state
            }
          }
        }
      }
    }
  }`);
const LATEST_CONTRACT_TX_BLOCK_HEIGHT_QUERY = gql(`
  query LATEST_CONTRACT_TX_BLOCK_HEIGHT_QUERY($address: HexEncoded!) {
    contractAction(address: $address) {
      transaction {
        block {
          height
        }
      }
    }
  }`);
const TXS_FROM_BLOCK_SUB = gql(`
  subscription TXS_FROM_BLOCK_SUB($offset: BlockOffset) {
    blocks(offset: $offset) {
      hash,
      height,
      transactions {
        hash
        identifiers
        contractActions {
          state
          address
        }
      }
    }
  }`);
const CONTRACT_STATE_QUERY = gql(`
  query CONTRACT_STATE_QUERY($address: HexEncoded!, $offset: ContractActionOffset) {
    contractAction(address: $address, offset: $offset) {
      state
    }
  }`);
const CONTRACT_STATE_SUB = gql(`
  subscription CONTRACT_STATE_SUB($address: HexEncoded!, $offset: BlockOffset) {
    contractActions(address: $address, offset: $offset) {
      state
    }
  }`);
const CONTRACT_AND_ZSWAP_STATE_QUERY = gql(`
  query BOTH_STATE_QUERY($address: HexEncoded!, $offset: ContractActionOffset) {
    contractAction(address: $address, offset: $offset) {
      state
      chainState
    }
  }`);

/**
 * An error describing the causes of error that occurred during server-side execution of
 * a query against the Indexer.
 */
class IndexerFormattedError extends Error {
    cause;
    /**
     * @param cause An array of GraphQL errors that occurred during the server-side execution.
     */
    constructor(cause) {
        super(`Indexer GraphQL error(s):\n${cause.reduce((acc, c, idx) => `${idx + 1}. ${c.message}:\n\t${acc}`, '')}`);
        this.cause = cause;
    }
}

const maybeThrowGraphQLErrors = (result) => {
    if (result.errors && result.errors.length > 0) {
        throw new IndexerFormattedError(result.errors);
    }
    return result;
};
const maybeThrowApolloError = (result) => {
    if (result.error) {
        throw new Error(result.error.message);
    }
    return result;
};
const maybeThrowErrors = (queryResult) => {
    maybeThrowApolloError(queryResult);
    return maybeThrowGraphQLErrors(queryResult);
};
const toByteArray = (s) => Buffer.from(s, 'hex');
const deserializeContractState = (s) => ContractState.deserialize(toByteArray(s), getRuntimeNetworkId());
const deserializeZswapState = (s) => ZswapChainState.deserialize(toByteArray(s), getLedgerNetworkId());
const deserializeTransaction = (s) => Transaction.deserialize(toByteArray(s), getLedgerNetworkId());
/**
 * This is a dirty hack. Prepends a network ID to the given contract address and
 * returns the result. As of ledger 3.0.0, the running node and indexer store
 * contract addresses with the network ID (in hex format) prepended to the address
 * while the ledger WASM API does not. So, before we query for a contract address,
 * we need to manually prepend the network ID to the contract address.
 *
 * @param contractAddress The contract address to which to prepend the network ID.
 */
const prependNetworkIdHex = (contractAddress) => `${networkIdToHex(getNetworkId())}${contractAddress}`;
const zenToRx = (zenObservable) => new Rx.Observable((subscriber) => zenObservable.subscribe(subscriber));
/**
 * The default time (in milliseconds) to wait between queries when polling.
 */
const DEFAULT_POLL_INTERVAL = 1000;
// Assumes that the block exists.
const blockOffsetToBlock$ = (apolloClient) => (offset) => zenToRx(apolloClient
    .subscribe({
    query: TXS_FROM_BLOCK_SUB,
    variables: {
        offset
    },
    fetchPolicy: 'no-cache'
})
    .map(maybeThrowGraphQLErrors)
    .map((fetchResult) => fetchResult.data.blocks));
const transactionIdToTransaction$ = (apolloClient) => (identifier) => zenToRx(apolloClient
    .watchQuery({
    query: TX_ID_QUERY,
    variables: {
        offset: { identifier }
    },
    pollInterval: DEFAULT_POLL_INTERVAL,
    fetchPolicy: 'no-cache',
    initialFetchPolicy: 'no-cache',
    nextFetchPolicy: 'no-cache'
})
    .map(maybeThrowErrors)
    .filter((maybeQueryResult) => maybeQueryResult.data.transactions.length !== 0)
    .map((maybeQueryResult) => ({
    height: maybeQueryResult.data.transactions[0].block.height
}))).pipe(Rx.concatMap(blockOffsetToBlock$(apolloClient)), Rx.concatMap(({ transactions }) => Rx.from(transactions)));
const transactionToContractState$ = (transactionId) => ({ identifiers, contractActions }) => Rx.zip(identifiers, contractActions).pipe(Rx.skipWhile((pair) => pair[0] !== transactionId), Rx.map((pair) => deserializeContractState(pair[1].state)));
const toTxStatus = (applyStage) => {
    if (applyStage === FailEntirely ||
        applyStage === FailFallible ||
        applyStage === SucceedEntirely) {
        return applyStage;
    }
    throw new Error(`Unexpected 'applyStage' value ${applyStage}`);
};
const blockToContractState$ = (contractAddress) => (block) => Rx.from(block.transactions).pipe(Rx.concatMap(({ contractActions }) => Rx.from(contractActions)), Rx.filter((call) => call.address === contractAddress), Rx.map((call) => deserializeContractState(call.state)));
const contractAddressToLatestBlockOffset$ = (apolloClient) => (contractAddress) => zenToRx(apolloClient
    .watchQuery({
    query: LATEST_CONTRACT_TX_BLOCK_HEIGHT_QUERY,
    variables: {
        address: contractAddress
    },
    pollInterval: DEFAULT_POLL_INTERVAL,
    fetchPolicy: 'no-cache',
    initialFetchPolicy: 'no-cache',
    nextFetchPolicy: 'no-cache'
})
    .map(maybeThrowErrors)
    .filter((maybeQueryResult) => maybeQueryResult.data.contractAction !== null)
    .map((queryResult) => {
    const contract = queryResult.data.contractAction;
    return contract.transaction.block.height;
})).pipe(Rx.take(1), Rx.map((height) => ({ height })));
// Assumes block already exists
const blockOffsetToContractState$ = (apolloClient) => (contractAddress) => (offset) => zenToRx(apolloClient
    .subscribe({
    query: CONTRACT_STATE_SUB,
    variables: {
        address: contractAddress,
        offset
    },
    fetchPolicy: 'no-cache'
})
    .map(maybeThrowGraphQLErrors)
    .map((queryResult) => queryResult.data.contractActions.state)
    .map(deserializeContractState));
const waitForContractToAppear = (apolloClient) => (contractAddress) => (offset) => zenToRx(apolloClient
    .watchQuery({
    query: CONTRACT_STATE_QUERY,
    variables: {
        address: contractAddress,
        offset
    },
    pollInterval: DEFAULT_POLL_INTERVAL,
    fetchPolicy: 'no-cache',
    initialFetchPolicy: 'no-cache',
    nextFetchPolicy: 'no-cache'
})
    .map(maybeThrowErrors)
    .filter((maybeQueryResult) => maybeQueryResult.data.contractAction !== null)
    .map((queryResult) => queryResult.data.contractAction.state)).pipe(Rx.take(1));
const waitForBlockToAppear = (apolloClient) => (offset) => zenToRx(apolloClient
    .watchQuery({
    query: BLOCK_QUERY,
    variables: {
        offset
    },
    pollInterval: DEFAULT_POLL_INTERVAL,
    fetchPolicy: 'no-cache',
    initialFetchPolicy: 'no-cache',
    nextFetchPolicy: 'no-cache'
})
    .map(maybeThrowErrors)
    .filter((fetchResult) => fetchResult.data.block !== null)).pipe(Rx.take(1));
const indexerPublicDataProviderInternal = (queryURL, subscriptionURL, webSocketImpl = ws.WebSocket) => {
    const queryURLObj = new URL(queryURL);
    if (queryURLObj.protocol !== 'http:' && queryURLObj.protocol !== 'https:') {
        throw new InvalidProtocolSchemeError(queryURLObj.protocol, ['http:', 'https:']);
    }
    const subscriptionURLObj = new URL(subscriptionURL);
    if (subscriptionURLObj.protocol !== 'ws:' && subscriptionURLObj.protocol !== 'wss:') {
        throw new InvalidProtocolSchemeError(subscriptionURLObj.protocol, ['ws:', 'wss:']);
    }
    // Construct the Apollo client.
    const link = createHttpLink({ fetch, uri: queryURL });
    // Retry link with exponential backoff.
    const retryLink = new RetryLink({
        delay: {
            initial: 1000,
            max: 10000,
            jitter: true
        },
        attempts: {
            max: 5
        }
    });
    // Combine the retry link with the HTTP link to form the final link.
    const apolloLink = from([retryLink, link]);
    const apolloClient = new ApolloClient({
        link: split(({ query }) => {
            const definition = getMainDefinition(query);
            return definition.kind === 'OperationDefinition' && definition.operation === 'subscription';
        }, new GraphQLWsLink(createClient({ url: subscriptionURL, webSocketImpl })), apolloLink),
        cache: new InMemoryCache()
    });
    return {
        async queryContractState(address, config) {
            let offset;
            if (config) {
                offset = {
                    blockOffset: config.type === 'blockHeight'
                        ? { height: config.blockHeight }
                        : { hash: config.blockHash }
                };
            }
            else {
                offset = null;
            }
            const maybeContractState = await apolloClient
                .query({
                query: CONTRACT_STATE_QUERY,
                variables: {
                    address,
                    offset
                },
                fetchPolicy: 'no-cache'
            })
                .then(maybeThrowErrors)
                .then((queryResult) => queryResult.data?.contractAction?.state ?? null);
            return maybeContractState ? deserializeContractState(maybeContractState) : null;
        },
        async queryZSwapAndContractState(address, config) {
            let offset;
            if (config) {
                offset = {
                    blockOffset: config.type === 'blockHeight'
                        ? { height: config.blockHeight }
                        : { hash: config.blockHash }
                };
            }
            else {
                offset = null;
            }
            const maybeContractStates = await apolloClient
                .query({
                query: CONTRACT_AND_ZSWAP_STATE_QUERY,
                variables: {
                    address,
                    offset
                },
                fetchPolicy: 'no-cache'
            })
                .then(maybeThrowErrors)
                .then((queryResult) => queryResult.data.contractAction);
            return maybeContractStates
                ? [
                    deserializeZswapState(maybeContractStates.chainState),
                    deserializeContractState(maybeContractStates.state)
                ]
                : null;
        },
        async queryDeployContractState(contractAddress) {
            return apolloClient
                .query({
                query: DEPLOY_CONTRACT_STATE_TX_QUERY,
                variables: {
                    address: contractAddress
                },
                fetchPolicy: 'no-cache'
            })
                .then((queryResult) => {
                if (queryResult.data.contractAction) {
                    const contract = queryResult.data.contractAction;
                    return 'deploy' in contract
                        ? contract.deploy.transaction.contractActions.find(({ address }) => address === contractAddress).state
                        : contract.state;
                }
                return null;
            })
                .then((maybeContractState) => maybeContractState ? deserializeContractState(maybeContractState) : null);
        },
        async watchForContractState(contractAddress) {
            return Rx.firstValueFrom(waitForContractToAppear(apolloClient)(contractAddress)(null).pipe(Rx.map(deserializeContractState)));
        },
        async watchForDeployTxData(contractAddress) {
            return Rx.firstValueFrom(zenToRx(apolloClient
                .watchQuery({
                query: DEPLOY_TX_QUERY,
                variables: {
                    address: contractAddress
                },
                pollInterval: DEFAULT_POLL_INTERVAL,
                fetchPolicy: 'no-cache',
                initialFetchPolicy: 'no-cache',
                nextFetchPolicy: 'no-cache'
            })
                .filter((maybeQueryResult) => maybeQueryResult.data.contractAction !== null)
                .map(maybeThrowErrors)
                .map((queryResults) => {
                const contract = queryResults.data.contractAction;
                return 'deploy' in contract ? contract.deploy.transaction : contract.transaction;
            })
                .map((transaction) => ({
                tx: deserializeTransaction(transaction.raw),
                status: toTxStatus(transaction.applyStage),
                txId: transaction.identifiers[transaction.contractActions.findIndex(({ address }) => address === contractAddress)],
                txHash: transaction.hash,
                blockHeight: transaction.block.height,
                blockHash: transaction.block.hash
            }))));
        },
        async watchForTxData(txId) {
            return Rx.firstValueFrom(zenToRx(apolloClient
                .watchQuery({
                query: TX_ID_QUERY,
                variables: { offset: { identifier: txId } },
                pollInterval: DEFAULT_POLL_INTERVAL,
                fetchPolicy: 'no-cache',
                initialFetchPolicy: 'no-cache',
                nextFetchPolicy: 'no-cache'
            })
                .map(maybeThrowErrors)
                .filter((maybeQueryResult) => maybeQueryResult.data.transactions.length !== 0)
                .map((queryResult) => queryResult.data.transactions[0])
                .map((transaction) => ({
                tx: deserializeTransaction(transaction.raw),
                status: toTxStatus(transaction.applyStage),
                txId,
                txHash: transaction.hash,
                blockHeight: transaction.block.height,
                blockHash: transaction.block.hash
            }))));
        },
        contractStateObservable(contractAddress, config = { type: 'latest' }) {
            if (config.type === 'txId') {
                const contractStates = transactionIdToTransaction$(apolloClient)(config.txId).pipe(Rx.concatMap(transactionToContractState$(config.txId)));
                return (config.inclusive ?? true) ? contractStates : contractStates.pipe(Rx.skip(1));
            }
            if (config.type === 'latest') {
                return contractAddressToLatestBlockOffset$(apolloClient)(contractAddress).pipe(Rx.concatMap(blockOffsetToBlock$(apolloClient)), Rx.concatMap(blockToContractState$(contractAddress)));
            }
            if (config.type === 'all') {
                return waitForContractToAppear(apolloClient)(contractAddress)(null).pipe(Rx.concatMap(() => blockOffsetToContractState$(apolloClient)(contractAddress)(null)));
            }
            const offset = config.type === 'blockHash' ? { hash: config.blockHash } : { height: config.blockHeight };
            const blocks = waitForBlockToAppear(apolloClient)(offset).pipe(Rx.concatMap(() => blockOffsetToBlock$(apolloClient)(offset)));
            const maybeShortenedBlocks = config.type === 'blockHeight' || config.type === 'blockHash'
                ? Rx.iif(() => config.inclusive ?? true, blocks, blocks.pipe(Rx.skip(1)))
                : blocks;
            return maybeShortenedBlocks.pipe(Rx.concatMap(blockToContractState$(contractAddress)));
        }
    };
};
/**
 * Constructs a {@link PublicDataProvider} based on an {@link ApolloClient}.
 *
 * @param queryURL The URL of a GraphQL server query endpoint.
 * @param subscriptionURL The URL of a GraphQL server subscription (websocket) endpoint.
 * @param webSocketImpl An optional websocket implementation for the Apollo client to use.
 *
 * TODO: Re-examine caching when 'ContractCall' and 'ContractDeploy' have transaction identifiers included.
 */
const indexerPublicDataProvider = (queryURL, subscriptionURL, webSocketImpl = ws.WebSocket) => {
    /**
     * This current object is a wrapper around the real implementation of the indexer client constructed
     * below. This wrapper just asserts that the input contract addresses are valid, and prepends the hex
     * representation of the network ID to all input contract addresses to work around a discrepancy
     * as of ledger 3.0.0 between the contract address representation on the indexer (with network ID)
     * and the address representation in the ledger WASM API (without network ID).
     */
    const publicDataProvider = indexerPublicDataProviderInternal(queryURL, subscriptionURL, webSocketImpl);
    return {
        contractStateObservable(contractAddress, config) {
            assertIsContractAddress(contractAddress);
            return publicDataProvider.contractStateObservable(prependNetworkIdHex(contractAddress), config);
        },
        queryContractState(contractAddress, config) {
            assertIsContractAddress(contractAddress);
            return publicDataProvider.queryContractState(prependNetworkIdHex(contractAddress), config);
        },
        queryDeployContractState(contractAddress) {
            assertIsContractAddress(contractAddress);
            return publicDataProvider.queryDeployContractState(prependNetworkIdHex(contractAddress));
        },
        queryZSwapAndContractState(contractAddress, config) {
            assertIsContractAddress(contractAddress);
            return publicDataProvider.queryZSwapAndContractState(prependNetworkIdHex(contractAddress), config);
        },
        watchForContractState(contractAddress) {
            assertIsContractAddress(contractAddress);
            return publicDataProvider.watchForContractState(prependNetworkIdHex(contractAddress));
        },
        watchForDeployTxData(contractAddress) {
            assertIsContractAddress(contractAddress);
            return publicDataProvider.watchForDeployTxData(prependNetworkIdHex(contractAddress));
        },
        watchForTxData(txId) {
            return publicDataProvider.watchForTxData(txId);
        }
    };
};

export { IndexerFormattedError, indexerPublicDataProvider };
//# sourceMappingURL=index.mjs.map
