import { createCoinInfo } from '@midnight-ntwrk/zswap';

class CounterOffer {
    imbalances;
    transactionCostModel;
    feeTokenType;
    inputsRecipe;
    outputsRecipe;
    constructor(imbalances, transactionCostModel, feeTokenType) {
        this.imbalances = imbalances;
        this.transactionCostModel = transactionCostModel;
        this.feeTokenType = feeTokenType;
        this.inputsRecipe = [];
        this.outputsRecipe = [];
    }
    findNonNativeImbalance() {
        for (const [tokenType, value] of this.imbalances) {
            if (tokenType !== this.feeTokenType && value !== 0n) {
                return [tokenType, value];
            }
        }
        return undefined;
    }
    findNativeImbalance() {
        const nativeImbalance = this.imbalances.get(this.feeTokenType);
        if (nativeImbalance !== undefined && nativeImbalance !== 0n) {
            return [this.feeTokenType, nativeImbalance];
        }
        return undefined;
    }
    addInput(input) {
        this.inputsRecipe.push(input);
        const imbalance = this.imbalances.get(input.type) || 0n;
        this.imbalances.set(input.type, imbalance + input.value);
        const nativeImbalance = this.imbalances.get(this.feeTokenType) || 0n;
        this.imbalances.set(this.feeTokenType, nativeImbalance - this.transactionCostModel.inputFeeOverhead);
    }
    addOutput(output) {
        const imbalance = this.imbalances.get(output.type) || 0n;
        const subtractFee = output.type === this.feeTokenType ? this.transactionCostModel.outputFeeOverhead : 0n;
        const absoluteCoinValue = output.value < 0n ? -output.value : output.value;
        this.outputsRecipe.push(createCoinInfo(output.type, absoluteCoinValue - subtractFee));
        this.imbalances.set(output.type, imbalance - absoluteCoinValue);
        if (output.type !== this.feeTokenType) {
            const nativeImbalance = this.imbalances.get(this.feeTokenType) || 0n;
            this.imbalances.set(this.feeTokenType, nativeImbalance - this.transactionCostModel.outputFeeOverhead);
        }
    }
}

const getBalanceRecipe = (coins, targetImbalances, transactionCostModel, feeTokenType) => {
    const counterOffer = createCounterOffer(coins, targetImbalances, transactionCostModel, feeTokenType);
    return {
        inputs: counterOffer.inputsRecipe,
        outputs: counterOffer.outputsRecipe,
    };
};
const createCounterOffer = (coins, targetImbalances, transactionCostModel, feeTokenType) => {
    // 1. Create an empty offer
    // 2. Calculate total fees to be paid for the unbalanced transaction and the offer
    // 3. Calculate resulting imbalances by merging ones from the unbalanced transaction, the offer and target imbalances
    const counterOffer = new CounterOffer(targetImbalances, transactionCostModel, feeTokenType);
    let imbalance;
    // 4. Verify if target imbalances are met. If they are, create transaction from the offer, merge with the unbalanced transaction, and return
    // 5. Sort token types present in result imbalances in a way, that DUST is left last and select first token type
    while ((imbalance = counterOffer.findNonNativeImbalance())) {
        coins = doBalance(imbalance, coins, counterOffer);
    }
    while ((imbalance = counterOffer.findNativeImbalance())) {
        coins = doBalance(imbalance, coins, counterOffer);
    }
    return counterOffer;
};
const doBalance = (imbalance, coins, counterOffer) => {
    const [tokenType, imbalanceAmount] = imbalance;
    // 6a. If the imbalance is positive and greater than the output fee,
    // create an output for self with the amount equal to imbalance
    const shouldAddOutput = (tokenType === counterOffer.feeTokenType &&
        imbalanceAmount >= counterOffer.transactionCostModel.outputFeeOverhead) ||
        (tokenType !== counterOffer.feeTokenType && imbalanceAmount > 0n);
    if (shouldAddOutput) {
        counterOffer.addOutput({ type: tokenType, value: imbalanceAmount });
    }
    else {
        // 6b. If the imbalance is negative, select a single coin of the selected type, and create an input
        const coin = chooseCoin(coins, { type: tokenType});
        if (typeof coin === 'undefined') {
            throw new Error(tokenType);
        }
        counterOffer.addInput(coin);
        coins = coins.filter((c) => c !== coin);
    }
    return coins;
};
const chooseCoin = (coins, coinToChoose) => {
    const filteredAndSortedCoins = coins
        .filter((coin) => coin.type === coinToChoose.type)
        .sort((a, b) => Number(a.value - b.value));
    return filteredAndSortedCoins[0] ?? undefined;
};

const emptyImbalances = new Map();
const createImbalances = (imbalances) => {
    const mappedImbalances = new Map();
    imbalances.forEach(([tokenType, value]) => {
        if (mappedImbalances.has(tokenType)) {
            mappedImbalances.set(tokenType, mappedImbalances.get(tokenType) + value);
        }
        else {
            mappedImbalances.set(tokenType, value);
        }
    });
    return mappedImbalances;
};
const mergeImbalances = (a, b) => {
    b.forEach((valueB, tokenType) => {
        const valueA = a.get(tokenType) || 0n;
        a.set(tokenType, valueA + valueB);
    });
    return a;
};

export { CounterOffer, createCounterOffer, createImbalances, emptyImbalances, getBalanceRecipe, mergeImbalances };
//# sourceMappingURL=index.js.map
