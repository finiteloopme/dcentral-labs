import type { Contract, ImpureCircuitId, PrivateStateId } from '@midnight-ntwrk/midnight-js-types';
import { type EncPublicKey } from '@midnight-ntwrk/ledger';
import type { CoinPublicKey } from '@midnight-ntwrk/compact-runtime';
import type { UnsubmittedCallTxData } from './tx-model';
import type { CallOptionsWithArguments, CallOptionsWithPrivateState, CallOptionsWithProviderDataDependencies } from './call';
import { type ContractProviders } from './contract-providers';
export declare function createUnprovenCallTxFromInitialStates<C extends Contract<undefined>, ICK extends ImpureCircuitId<C>>(options: CallOptionsWithProviderDataDependencies<C, ICK>, walletCoinPublicKey: CoinPublicKey, walletEncryptionPublicKey: EncPublicKey): UnsubmittedCallTxData<C, ICK>;
export declare function createUnprovenCallTxFromInitialStates<C extends Contract, ICK extends ImpureCircuitId<C>>(options: CallOptionsWithPrivateState<C, ICK>, walletCoinPublicKey: CoinPublicKey, walletEncryptionPublicKey: EncPublicKey): UnsubmittedCallTxData<C, ICK>;
/**
 * Base type for configuration for a call transaction; identical to {@link CallOptionsWithArguments}.
 */
export type CallTxOptionsBase<C extends Contract, ICK extends ImpureCircuitId<C>> = CallOptionsWithArguments<C, ICK>;
/**
 * Call transaction options with the private state ID to use to store the new private
 * state resulting from the circuit call. Since a private state should already be
 * stored at the given private state ID, we don't need an 'initialPrivateState' like
 * in {@link DeployTxOptionsWithPrivateState}.
 */
export type CallTxOptionsWithPrivateStateId<C extends Contract, ICK extends ImpureCircuitId<C>> = CallTxOptionsBase<C, ICK> & {
    /**
     * The identifier for the private state of the contract.
     */
    readonly privateStateId: PrivateStateId;
};
/**
 * Call transaction configuration.
 */
export type CallTxOptions<C extends Contract, ICK extends ImpureCircuitId<C>> = CallTxOptionsBase<C, ICK> | CallTxOptionsWithPrivateStateId<C, ICK>;
/**
 * The minimum set of providers needed to create a call transaction, the ZK
 * artifact provider and a wallet. By defining this type, users can choose to
 * omit a private state provider if they're creating a call transaction for a
 * contract with no private state.
 */
export type UnprovenCallTxProvidersBase = Pick<ContractProviders, 'publicDataProvider' | 'walletProvider'>;
/**
 * Same providers as {@link UnprovenCallTxProvidersBase} with an additional private
 * state provider to store the new private state resulting from the circuit call -
 * only used when creating a call transaction for a contract with a private state.
 */
export type UnprovenCallTxProvidersWithPrivateState<C extends Contract> = UnprovenCallTxProvidersBase & Pick<ContractProviders<C>, 'privateStateProvider'>;
/**
 * Providers needed to create a call transaction.
 */
export type UnprovenCallTxProviders<C extends Contract> = UnprovenCallTxProvidersBase | UnprovenCallTxProvidersWithPrivateState<C>;
export declare function createUnprovenCallTx<C extends Contract<undefined>, ICK extends ImpureCircuitId<C>>(providers: UnprovenCallTxProvidersBase, options: CallTxOptionsBase<C, ICK>): Promise<UnsubmittedCallTxData<C, ICK>>;
export declare function createUnprovenCallTx<C extends Contract, ICK extends ImpureCircuitId<C>>(providers: UnprovenCallTxProvidersWithPrivateState<C>, options: CallTxOptionsWithPrivateStateId<C, ICK>): Promise<UnsubmittedCallTxData<C, ICK>>;
//# sourceMappingURL=unproven-call-tx.d.ts.map