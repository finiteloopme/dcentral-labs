import { type SigningKey } from '@midnight-ntwrk/compact-runtime';
import type { PrivateState, PrivateStateId, Contract, ImpureCircuitId } from '@midnight-ntwrk/midnight-js-types';
import type { FinalizedDeployTxData } from './tx-model';
import type { FoundContract } from './find-deployed-contract';
import type { ContractConstructorOptionsWithArguments } from './call-constructor';
import { type ContractProviders } from './contract-providers';
/**
 * Base type for configuration for {@link deployContract}; identical to
 * {@link ContractConstructorOptionsWithArguments} except the `signingKey` is
 * now optional, since {@link deployContract} will generate a fresh signing key
 * in the event that `signingKey` is undefined.
 */
export type DeployContractOptionsBase<C extends Contract> = ContractConstructorOptionsWithArguments<C> & {
    /**
     * The signing key to add as the to-be-deployed contract's maintenance authority.
     * If undefined, a new signing key is sampled and used as the CMA then stored
     * in the private state provider under the newly deployed contract's address.
     * Otherwise, the passed signing key is added as the CMA. The second case is
     * useful when you want to use the same CMA for two different contracts.
     */
    readonly signingKey?: SigningKey;
};
/**
 * {@link deployContract} base options with information needed to store private states;
 * only used if the contract being deployed has a private state.
 */
export type DeployContractOptionsWithPrivateState<C extends Contract> = DeployContractOptionsBase<C> & {
    /**
     * An identifier for the private state of the contract being found.
     */
    readonly privateStateId: PrivateStateId;
    /**
     * The private state to run the circuit against.
     */
    readonly initialPrivateState: PrivateState<C>;
};
/**
 * Configuration for {@link deployContract}.
 */
export type DeployContractOptions<C extends Contract> = DeployContractOptionsBase<C> | DeployContractOptionsWithPrivateState<C>;
/**
 * Interface for a contract that has been deployed to the blockchain.
 */
export type DeployedContract<C extends Contract> = FoundContract<C> & {
    /**
     * Data resulting from the deployment transaction that created this contract. The information in a
     * {@link deployTxData} contains additional private information that does not
     * exist in {@link FoundContract.deployTxData} because certain private data is only available to
     * the deployer of a contract.
     */
    readonly deployTxData: FinalizedDeployTxData<C>;
};
export declare function deployContract<C extends Contract<undefined>>(providers: ContractProviders<C, ImpureCircuitId<C>, unknown>, options: DeployContractOptionsBase<C>): Promise<DeployedContract<C>>;
export declare function deployContract<C extends Contract>(providers: ContractProviders<C>, options: DeployContractOptionsWithPrivateState<C>): Promise<DeployedContract<C>>;
//# sourceMappingURL=deploy-contract.d.ts.map