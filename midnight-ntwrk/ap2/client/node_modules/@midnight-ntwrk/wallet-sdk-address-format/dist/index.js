import { NetworkId, EncryptionSecretKey } from '@midnight-ntwrk/zswap';
import { bech32m } from '@scure/base';

class MidnightBech32m {
    type;
    network;
    data;
    static prefix = 'mn';
    static validateSegment(segmentName, segment) {
        const result = /^[A-Za-z1-9-]+$/.test(segment);
        if (!result) {
            throw new Error(`Segment ${segmentName}: ${segment} contains disallowed characters. Allowed characters are only numbers, latin letters and a hyphen`);
        }
    }
    static parse(bech32string) {
        const bech32parsed = bech32m.decodeToBytes(bech32string);
        const [prefix, type, network = null] = bech32parsed.prefix.split('_');
        if (prefix != MidnightBech32m.prefix) {
            throw new Error(`Expected prefix ${MidnightBech32m.prefix}`);
        }
        MidnightBech32m.validateSegment('type', type);
        if (network != null) {
            MidnightBech32m.validateSegment('network', network);
        }
        return new MidnightBech32m(type, network, Buffer.from(bech32parsed.bytes));
    }
    constructor(type, network, data) {
        this.type = type;
        this.network = network;
        this.data = data;
        MidnightBech32m.validateSegment('type', type);
        if (network != null) {
            MidnightBech32m.validateSegment('network', network);
        }
    }
    asString() {
        const networkSegment = this.network == null ? '' : `_${this.network}`;
        return bech32m.encode(`${MidnightBech32m.prefix}_${this.type}${networkSegment}`, bech32m.toWords(this.data), false);
    }
}
class Bech32mCodec {
    type;
    dataToBytes;
    dataFromBytes;
    constructor(type, dataToBytes, dataFromBytes) {
        this.type = type;
        this.dataToBytes = dataToBytes;
        this.dataFromBytes = dataFromBytes;
    }
    encode(networkId, data) {
        const context = Bech32mCodec.createContext(networkId);
        return new MidnightBech32m(this.type, context.networkId, this.dataToBytes(data));
    }
    decode(networkId, repr) {
        const context = Bech32mCodec.createContext(networkId);
        if (repr.type != this.type) {
            throw new Error(`Expected type ${this.type}, got ${repr.type}`);
        }
        if (context.networkId != repr.network) {
            throw new Error(`Expected ${context.networkId ?? 'mainnet'} address, got ${repr.network ?? 'mainnet'} one`);
        }
        return this.dataFromBytes(repr.data);
    }
    static createContext(networkId) {
        if (networkId === null) {
            return { networkId: null };
        }
        else if (typeof networkId === 'string') {
            return { networkId };
        }
        else {
            return Bech32mCodec.createContextFromZswap(networkId);
        }
    }
    static createContextFromZswap(networkId) {
        switch (networkId) {
            case NetworkId.DevNet:
                return { networkId: 'dev' };
            case NetworkId.MainNet:
                return { networkId: null };
            case NetworkId.TestNet:
                return { networkId: 'test' };
            case NetworkId.Undeployed:
                return { networkId: 'undeployed' };
            default:
                return { networkId: null };
        }
    }
}
class ShieldedAddress {
    coinPublicKey;
    encryptionPublicKey;
    static codec = new Bech32mCodec('shield-addr', (addr) => Buffer.concat([addr.coinPublicKey.data, addr.encryptionPublicKey.data]), (bytes) => {
        const coinPublicKey = new ShieldedCoinPublicKey(bytes.subarray(0, ShieldedCoinPublicKey.key_length));
        const encryptionPublicKey = new ShieldedEncryptionPublicKey(bytes.subarray(ShieldedCoinPublicKey.key_length));
        return new ShieldedAddress(coinPublicKey, encryptionPublicKey);
    });
    constructor(coinPublicKey, encryptionPublicKey) {
        this.coinPublicKey = coinPublicKey;
        this.encryptionPublicKey = encryptionPublicKey;
    }
    coinPublicKeyString() {
        return this.coinPublicKey.data.toString('hex');
    }
    encryptionPublicKeyString() {
        return this.encryptionPublicKey.data.toString('hex');
    }
}
class ShieldedEncryptionSecretKey {
    zswap;
    static codec = new Bech32mCodec('shield-esk', (esk) => Buffer.from(esk.zswap.yesIKnowTheSecurityImplicationsOfThis_serialize(NetworkId.Undeployed).subarray(1)), (repr) => new ShieldedEncryptionSecretKey(EncryptionSecretKey.deserialize(Buffer.concat([Buffer.of(0), repr]), NetworkId.Undeployed)));
    // There are some bits in serialization of field elements and elliptic curve points, that are hard to replicate
    // Thus using zswap implementation directly for serialization purposes
    constructor(zswap) {
        this.zswap = zswap;
    }
}
class ShieldedCoinPublicKey {
    data;
    static key_length = 32;
    static codec = new Bech32mCodec('shield-cpk', (cpk) => cpk.data, (repr) => new ShieldedCoinPublicKey(repr));
    constructor(data) {
        this.data = data;
        if (data.length != ShieldedCoinPublicKey.key_length) {
            throw new Error('Coin public key needs to be 32 bytes long');
        }
    }
}
class ShieldedEncryptionPublicKey {
    data;
    static key_length = 32;
    static codec = new Bech32mCodec('shield-epk', (cpk) => cpk.data, (repr) => new ShieldedEncryptionPublicKey(repr));
    constructor(data) {
        this.data = data;
    }
}

export { Bech32mCodec, MidnightBech32m, ShieldedAddress, ShieldedCoinPublicKey, ShieldedEncryptionPublicKey, ShieldedEncryptionSecretKey };
//# sourceMappingURL=index.js.map
