import type { Transaction, TransactionHash, TransactionId } from '@midnight-ntwrk/ledger';
/**
 * A type representing a prover key derived from a contract circuit.
 */
export type ProverKey = Uint8Array & {
    /**
     * Unique symbol brand.
     */
    readonly ProverKey: unique symbol;
};
/**
 * Creates a branded prover key representation from a prover key binary.
 *
 * @param uint8Array The prover key binary.
 */
export declare const createProverKey: (uint8Array: Uint8Array) => ProverKey;
/**
 * A type representing a verifier key derived from a contract circuit.
 */
export type VerifierKey = Uint8Array & {
    /**
     * Unique symbol brand.
     */
    readonly VerifierKey: unique symbol;
};
/**
 * Creates a branded verifier key representation from a verifier key binary.
 *
 * @param uint8Array The verifier key binary.
 */
export declare const createVerifierKey: (uint8Array: Uint8Array) => VerifierKey;
/**
 * A type representing a zero-knowledge circuit intermediate representation derived from a contract circuit.
 */
export type ZKIR = Uint8Array & {
    /**
     * Unique symbol brand.
     */
    readonly ZKIR: unique symbol;
};
/**
 * Creates a branded ZKIR representation from a ZKIR binary.
 *
 * @param uint8Array The ZKIR binary.
 */
export declare const createZKIR: (uint8Array: Uint8Array) => ZKIR;
/**
 * Contains all information required by the {@link ProofProvider}
 * @typeParam K - The type of the circuit ID.
 */
export interface ZKConfig<K extends string> {
    /**
     * A circuit identifier.
     */
    readonly circuitId: K;
    /**
     * The prover key corresponding to {@link ZKConfig.circuitId}.
     */
    readonly proverKey: ProverKey;
    /**
     * The verifier key corresponding to {@link ZKConfig.circuitId}.
     */
    readonly verifierKey: VerifierKey;
    /**
     * The zero-knowledge intermediate representation corresponding to {@link ZKConfig.circuitId}.
     */
    readonly zkir: ZKIR;
}
/**
 * A type representing a proven, unbalanced transaction.
 */
export type UnbalancedTransaction = Transaction & {
    /**
     * Unique symbol brand.
     */
    readonly UnbalancedTransaction: unique symbol;
};
/**
 * Creates an {@link UnbalancedTransaction} from a ledger transaction.
 *
 * @param tx The ledger transaction to wrap.
 */
export declare const createUnbalancedTx: (tx: Transaction) => UnbalancedTransaction;
/**
 * A type representing a proven, balanced, submittable transaction.
 */
export type BalancedTransaction = Transaction & {
    /**
     * Unique symbol brand.
     */
    readonly BalancedTransaction: unique symbol;
};
/**
 * Creates an {@link BalancedTransaction} from a ledger transaction.
 * @param tx The ledger transaction to wrap.
 */
export declare const createBalancedTx: (tx: Transaction) => BalancedTransaction;
/**
 * Indicates that the transaction is invalid.
 */
export declare const FailEntirely: "FailEntirely";
/**
 * Indicates that the transaction is valid but the portion of the transcript
 * that is allowed to fail (the portion after a checkpoint) did fail. All effects
 * from the guaranteed part of the transaction are kept but the effects from the
 * fallible part of the transaction are discarded.
 */
export declare const FailFallible: "FailFallible";
/**
 * Indicates that the guaranteed and fallible portions of the transaction were
 * successful.
 */
export declare const SucceedEntirely: "SucceedEntirely";
/**
 * The status of a transaction.
 */
export type TxStatus = typeof FailEntirely | typeof FailFallible | typeof SucceedEntirely;
/**
 * Block identifier
 */
export type BlockHash = string;
/**
 * Data for any finalized transaction.
 */
export interface FinalizedTxData {
    /**
     * The transaction that was finalized.
     */
    readonly tx: Transaction;
    /**
     * The status of a submitted transaction.
     */
    readonly status: TxStatus;
    /**
     * The transaction ID of the submitted transaction.
     */
    readonly txId: TransactionId;
    /**
     * The transaction hash of the transaction in which the original transaction was included.
     */
    readonly txHash: TransactionHash;
    /**
     * The block hash of the block in which the transaction was included.
     */
    readonly blockHash: BlockHash;
    /**
     * The block height of the block in which the transaction was included.
     */
    readonly blockHeight: number;
}
//# sourceMappingURL=midnight-types.d.ts.map