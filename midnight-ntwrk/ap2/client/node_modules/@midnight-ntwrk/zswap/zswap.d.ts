// DO NOT EDIT THIS FILE; IT IS AUTOMATICALLY GENERATED
/**
 * A contract address, as a hex-encoded 35-byte string
 */
export type ContractAddress = string;
/**
 * A token type (or color), as a hex-encoded 35-byte string
 */
export type TokenType = string;

/**
 * A user secret key capable of spending Zswap coins
 */
export class CoinSecretKey {
  private constructor();

  yesIKnowTheSecurityImplicationsOfThis_serialize(netid: NetworkId): Uint8Array;
}

/**
 * A user public key capable of receiving Zswap coins, as a hex-encoded 35-byte
 * string
 */
export type CoinPublicKey = string;
/**
 * A Zswap coin commitment, as a hex-encoded 256-bit bitstring
 */
export type CoinCommitment = string;
/**
 * A Zswap nullifier, as a hex-encoded 256-bit bitstring
 */
export type Nullifier = string;
/**
 * A Zswap nonce, as a hex-encoded 256-bit string
 */
export type Nonce = string;
/**
 * Information required to create a new coin, alongside details about the
 * recipient
 */
export type CoinInfo = { type: TokenType, nonce: Nonce, value: bigint };
/**
 * Information required to spend an existing coin, alongside authorization of
 * the owner
 */
export type QualifiedCoinInfo = { type: TokenType, nonce: Nonce, value: bigint, mt_index: bigint };
/**
 * The network currently being targeted
 */
export enum NetworkId {
  /**
   * A local test network
   */
  Undeployed = 0,
  /**
   * A developer network, not guaranteed to be persistent
   */
  DevNet = 1,
  /**
   * A persistent testnet
   */
  TestNet = 2,
  /**
   * The Midnight mainnet
   */
  MainNet = 3,
}
/**
 * Samples a uniform contract address, for use in testing
 */
export function sampleContractAddress(): ContractAddress;
/**
 * Samples a uniform token type, for use in testing
 */
export function sampleTokenType(): TokenType;

/**
 * A Midnight transaction, consisting a guaranteed and fallible {@link Offer},
 * and contract call information hidden from this API.
 *
 * The guaranteed section are run first, and fee payment is taken during this
 * part. If it succeeds, the fallible section is also run, and atomically
 * rolled back if it fails.
 */
export class Transaction {
  private constructor();
  /**
   * Type hint that you should use an external proving function, for instance
   * via the proof server.
   */
  static fromUnproven(prove: (unproven: UnprovenTransaction) => Promise<Transaction>, unproven: UnprovenTransaction): Promise<Transaction>;
  /**
   * Merges this transaction with another
   *
   * @throws If both transactions have contract interactions, or they spend the
   * same coins
   */
  merge(other: Transaction): Transaction;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): Transaction;
  /**
   * Erases the proofs contained in this transaction
   */
  eraseProofs(): ProofErasedTransaction;
  /**
   * Returns the hash associated with this transaction. Due to the ability to
   * merge transactions, this should not be used to watch for a specific
   * transaction.
   */
  transactionHash(): TransactionHash;
  /**
   * Returns the set of identifiers contained within this transaction. Any of
   * these *may* be used to watch for a specific transaction.
   */
  identifiers(): TransactionId[];
  /**
   * For given fees, and a given section (guaranteed/fallible), what the
   * surplus or deficit of this transaction in any token type is.
   */
  imbalances(guaranteed: boolean, fees?: bigint): Map<TokenType, bigint>;
  /**
   * The cost of this transaction, in the atomic unit of the base token
   */
  fees(params: LedgerParameters): bigint;
  toString(compact?: boolean): string;
  /**
   * The mint this transaction represents, if applicable
   */
  readonly mint: AuthorizedMint | undefined;
  /**
   * The fallible Zswap offer
   */
  readonly fallibleCoins: Offer | undefined;
  /**
   * The guaranteed Zswap offer
   */
  readonly guaranteedCoins: Offer | undefined;
}

/**
 * {@link Transaction}, prior to being proven
 *
 * All "shielded" information in the transaction can still be extracted at this
 * stage!
 */
export class UnprovenTransaction {
  /**
   * Creates the transaction from guaranteed/fallible {@link UnprovenOffer}s
   */
  constructor(guaranteed: UnprovenOffer, fallible?: UnprovenOffer);
  /**
   * Creates a minting claim transaction, the funds claimed must have been
   * legitimately minted previously.
   */
  static fromMint(mint: UnprovenAuthorizedMint): UnprovenTransaction;
  /**
   * Merges this transaction with another
   *
   * @throws If both transactions have contract interactions, or they spend the
   * same coins
   */
  merge(other: UnprovenTransaction): UnprovenTransaction;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): UnprovenTransaction;
  /**
   * Erases the proofs contained in this transaction
   */
  eraseProofs(): ProofErasedTransaction;
  /**
   * Returns the set of identifiers contained within this transaction. Any of
   * these *may* be used to watch for a specific transaction.
   */
  identifiers(): TransactionId[];
  toString(compact?: boolean): string;
  /**
   * The mint this transaction represents, if applicable
   */
  readonly mint: UnprovenAuthorizedMint | undefined;
  /**
   * The fallible Zswap offer
   */
  readonly fallibleCoins: UnprovenOffer | undefined;
  /**
   * The guaranteed Zswap offer
   */
  readonly guaranteedCoins: UnprovenOffer | undefined;
}

/**
 * {@link Transaction}, with all proof information erased
 *
 * Primarily for use in testing, or handling data known to be correct from
 * external information
 */
export class ProofErasedTransaction {
  private constructor();
  /**
   * Merges this transaction with another
   *
   * @throws If both transactions have contract interactions, or they spend the
   * same coins
   */
  merge(other: ProofErasedTransaction): ProofErasedTransaction;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): ProofErasedTransaction;
  /**
   * Returns the set of identifiers contained within this transaction. Any of
   * these *may* be used to watch for a specific transaction.
   */
  identifiers(): TransactionId[];
  /**
   * For given fees, and a given section (guaranteed/fallible), what the
   * surplus or deficit of this transaction in any token type is.
   */
  imbalances(guaranteed: boolean, fees?: bigint): Map<TokenType, bigint>;
  /**
   * The cost of this transaction, in the atomic unit of the base token
   */
  fees(params: LedgerParameters): bigint;
  toString(compact?: boolean): string;
  /**
   * The mint this transaction represents, if applicable
   */
  readonly mint: ProofErasedAuthorizedMint | undefined;
  /**
   * The fallible Zswap offer
   */
  readonly fallibleCoins: ProofErasedOffer | undefined;
  /**
   * The guaranteed Zswap offer
   */
  readonly guaranteedCoins: ProofErasedOffer | undefined;
}
/**
 * The hash of a transaction, as a hex-encoded 256-bit bytestring
 */
export type TransactionHash = string;
/**
 * A transaction identifier, used to index merged transactions
 */
export type TransactionId = string;
/**
 * An encryption public key, used to inform users of new coins sent to them
 */
export type EncPublicKey = string;

/**
 * Samples a dummy user coin public key, for use in testing
 */
export function sampleCoinPublicKey(): CoinPublicKey;
/**
 * Samples a dummy user encryption public key, for use in testing
 */
export function sampleEncryptionPublicKey(): EncPublicKey;
/**
 * Creates a new {@link CoinInfo}, sampling a uniform nonce
 */
export function createCoinInfo(type_: TokenType, value: bigint): CoinInfo;
/**
 * The base/system token type
 */
export function nativeToken(): TokenType;

/**
 * Calculate commitment of a coin owned by a user
 */
export function coinCommitment(coin: CoinInfo, coinPublicKey: CoinPublicKey): CoinCommitment;

/**
 * Calculate nullifier of a coin owned by a user
 */
export function coinNullifier(coin: CoinInfo, coinSecretKey: CoinSecretKey): Nullifier;

/**
 * Parameters used by the Midnight ledger, including transaction fees and
 * bounds
 */
export class LedgerParameters {
  private constructor();
  /**
   * A dummy set of testing parameters
   */
  static dummyParameters(): LedgerParameters;
  /**
   * The cost model used for transaction fees contained in these parameters
   */
  readonly transactionCostModel: TransactionCostModel;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): LedgerParameters;
  toString(compact?: boolean): string;
}

export class TransactionCostModel {
  private constructor();
  /**
   * A dummy cost model, for use in testing
   */
  static dummyTransactionCostModel(): TransactionCostModel;
  /**
   * The increase in fees to expect from adding a new input to a transaction
   */
  readonly inputFeeOverhead: bigint;
  /**
   * The increase in fees to expect from adding a new output to a transaction
   */
  readonly outputFeeOverhead: bigint;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): TransactionCostModel;
  toString(compact?: boolean): string;
}


/**
 * A compact delta on the coin commitments Merkle tree, used to keep local
 * spending trees in sync with the global state without requiring receiving all
 * transactions.
 */
export class MerkleTreeCollapsedUpdate {
  /**
   * Create a new compact update from a non-compact state, and inclusive
   * `start` and `end` indices
   *
   * @throws If the indices are out-of-bounds for the state, or `end < start`
   */
  constructor(state: ZswapChainState, start: bigint, end: bigint);
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): MerkleTreeCollapsedUpdate;
  toString(compact?: boolean): string;
}

/**
 * Holds the encryption secret key of a user, which may be used to determine if
 * a given offer contains outputs addressed to this user
 */
export class EncryptionSecretKey {
  private constructor();
  test(offer: Offer): boolean;
  yesIKnowTheSecurityImplicationsOfThis_serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): EncryptionSecretKey
}

export class SecretKeys {
  private constructor();
  /**
   * Derives secret keys from a 32-byte seed
   */
  static fromSeed(seed: Uint8Array): SecretKeys;

  /**
   * Derives secret keys from a 32-byte seed using deprecated implementation.
   * Use only for compatibility purposes
   */
  static fromSeedRng(seed: Uint8Array): SecretKeys;

  readonly coinPublicKey: CoinPublicKey;
  readonly coinSecretKey: CoinSecretKey
  readonly encryptionPublicKey: EncPublicKey;
  readonly encryptionSecretKey: EncryptionSecretKey;
}

/**
 * The on-chain state of Zswap, consisting of a Merkle tree of coin
 * commitments, a set of nullifiers, an index into the Merkle tree, and a set
 * of valid past Merkle tree roots
 */
export class ZswapChainState {
  constructor();
  serialize(netid: NetworkId): Uint8Array;
  /**
   * The first free index in the coin commitment tree
   */
  readonly firstFree: bigint;
  static deserialize(raw: Uint8Array, netid: NetworkId): ZswapChainState;
  /**
   * Given a whole ledger serialized state, deserialize only the Zswap portion
   */
  static deserializeFromLedgerState(raw: Uint8Array, netid: NetworkId): ZswapChainState;
  /**
   * Try to apply an {@link Offer} to the state, returning the updated state
   * and a map on newly inserted coin commitments to their inserted indices.
   *
   * @param whitelist - A set of contract addresses that are of interest. If
   * set, *only* these addresses are tracked, and all other information is
   * discarded.
   */
  tryApply(offer: Offer, whitelist?: Set<ContractAddress>): [ZswapChainState, Map<CoinCommitment, bigint>];
  /**
   * {@link tryApply} for {@link ProofErasedOffer}s
   */
  tryApplyProofErased(offer: ProofErasedOffer, whitelist?: Set<ContractAddress>): [ZswapChainState, Map<CoinCommitment, bigint>];
  toString(compact?: boolean): string;
}

/**
 * The local state of a user/wallet, consisting of a set
 * of unspent coins
 *
 * It also keeps track of coins that are in-flight, either expecting to spend
 * or expecting to receive, and a local copy of the global coin commitment
 * Merkle tree to generate proofs against.
 */
export class LocalState {
  /**
   * Creates a new, empty state
   */
  constructor();

  /**
   * Applies a collapsed Merkle tree update to the current local state, fast
   * forwarding through the indices included in it, if it is a correct update.
   *
   * The general flow for usage if Alice is in state A, and wants to ask Bob how to reach the new state B, is:
   *  - Find where she left off – what's her firstFree?
   *  - Find out where she's going – ask for Bob's firstFree.
   *  - Find what contents she does care about – ask Bob for the filtered
   *    entries she want to include proper in her tree.
   *  - In order, of Merkle tree indicies:
   *    - Insert (with `apply` offers Alice cares about).
   *    - Skip (with this method) sections Alice does not care about, obtaining
   *      the collapsed update covering the gap from Bob.
   * Note that `firstFree` is not included in the tree itself, and both ends of
   * updates *are* included.
   */
  applyCollapsedUpdate(update: MerkleTreeCollapsedUpdate): LocalState;
  /**
   * Locally marks an offer as failed, allowing inputs used in it to be
   * spendable once more.
   */
  applyFailed(offer: Offer): LocalState;
  /**
   * Locally marks an proof-erased offer as failed, allowing inputs used in it
   * to be spendable once more.
   */
  applyFailedProofErased(offer: ProofErasedOffer): LocalState;
  /**
   * Locally applies an offer to the current state, returning the updated state
   */
  apply(secretKeys: SecretKeys, offer: Offer): LocalState;
  /**
   * Locally applies a proof-erased offer to the current state, returning the
   * updated state
   */
  applyProofErased(secretKeys: SecretKeys, offer: ProofErasedOffer): LocalState;
  /**
   * Locally applies a transaction to the current state, returning the updated
   * state
   *
   * @param res - The result type of applying this transaction against the
   * ledger state
   */
  applyTx(secretKeys: SecretKeys, tx: Transaction, res: 'success' | 'partialSuccess' | 'failure'): LocalState;
  /**
   * Locally applies a proof-erased transaction to the current state, returning
   * the updated state
   *
   * @param res - The result type of applying this transaction against the
   * ledger state
   */
  applyProofErasedTx(secretKeys: SecretKeys, tx: ProofErasedTransaction, res: 'success' | 'partialSuccess' | 'failure'): LocalState;
  /**
   * Locally applies a system transaction to the current state, returning the
   * updated state
   */
  applySystemTx(secretKeys: SecretKeys, tx: SystemTransaction): LocalState;
  /**
   * Initiates a new spend of a specific coin, outputting the corresponding
   * {@link UnprovenInput}, and the updated state marking this coin as
   * in-flight.
   */
  spend(secretKeys: SecretKeys, coin: QualifiedCoinInfo, segment: number): [LocalState, UnprovenInput];
  /**
   * Initiates a new spend of a new-yet-received output, outputting the
   * corresponding {@link UnprovenTransient}, and the updated state marking
   * this coin as in-flight.
   */
  spendFromOutput(secretKeys: SecretKeys, coin: QualifiedCoinInfo, segment: number, output: UnprovenOutput): [LocalState, UnprovenTransient];
  /**
   * Adds a coin to the list of coins that are expected to be received
   *
   * This should be used if an output is creating a coin for this wallet, which
   * does not contain a ciphertext to detect it. In this case, the wallet must
   * know the commitment ahead of time to notice the receipt.
   */
  watchFor(coinPublicKey: CoinPublicKey, coin: CoinInfo): LocalState;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): LocalState;
  toString(compact?: boolean): string;
  /**
   * The set of *spendable* coins of this wallet
   */
  readonly coins: Set<QualifiedCoinInfo>;
  /**
   * The first free index in the internal coin commitments Merkle tree.
   * This may be used to identify which merkle tree updates are necessary.
   */
  readonly firstFree: bigint;
  /**
   * The outputs that this wallet is expecting to receive in the future
   */
  readonly pendingOutputs: Map<CoinCommitment, CoinInfo>;
  /**
   * The spends that this wallet is expecting to be finalized on-chain in the
   * future
   */
  readonly pendingSpends: Map<Nullifier, QualifiedCoinInfo>;
}

/**
 * A shielded transaction input
 */
export class Input {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): Input;
  toString(compact?: boolean): string;
  /**
   * The contract address receiving the input, if the sender is a contract
   */
  readonly contractAddress: ContractAddress | undefined;
  /**
   * The nullifier of the input
   */
  readonly nullifier: Nullifier;
}

/**
 * A {@link Input}, before being proven
 *
 * All "shielded" information in the input can still be extracted at this
 * stage!
 */
export class UnprovenInput {
  private constructor();
  /**
   * Creates a new input, spending a specific coin from a smart contract,
   * against a state which contains this coin.
   *
   * Note that inputs created in this way *also* need to be authorized by the
   * contract
   */
  static newContractOwned(coin: QualifiedCoinInfo, segment: number, contract: ContractAddress, state: ZswapChainState): UnprovenInput;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): UnprovenInput;
  toString(compact?: boolean): string;
  /**
   * The contract address receiving the input, if the sender is a contract
   */
  readonly contractAddress: ContractAddress | undefined;
  /**
   * The nullifier of the input
   */
  readonly nullifier: Nullifier;
}

/**
 * A {@link Input}, with all proof information erased
 *
 * Primarily for use in testing, or handling data known to be correct from
 * external information
 */
export class ProofErasedInput {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): ProofErasedInput;
  toString(compact?: boolean): string;
  /**
   * The contract address receiving the input, if the sender is a contract
   */
  readonly contractAddress: ContractAddress | undefined;
  /**
   * The nullifier of the input
   */
  readonly nullifier: Nullifier;
}

/**
 * A shielded transaction output
 */
export class Output {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): Output;
  toString(compact?: boolean): string;
  /**
   * The commitment of the output
   */
  readonly commitment: CoinCommitment;
  /**
   * The contract address receiving the output, if the recipient is a contract
   */
  readonly contractAddress: ContractAddress | undefined;
}

/**
 * An {@link Output} before being proven
 *
 * All "shielded" information in the output can still be extracted at this
 * stage!
 */
export class UnprovenOutput {
  private constructor();
  /**
   * Creates a new output, targeted to a user's coin public key.
   *
   * Optionally the output contains a ciphertext encrypted to the user's
   * encryption public key, which may be omitted *only* if the {@link CoinInfo}
   * is transferred to the recipient another way
   */
  static new(coin: CoinInfo, segment: number, target_cpk: CoinPublicKey, target_epk: EncPublicKey): UnprovenOutput;
  /**
   * Creates a new output, targeted to a smart contract
   *
   * A contract must *also* explicitly receive a coin created in this way for
   * the output to be valid
   */
  static newContractOwned(coin: CoinInfo, segment: number, contract: ContractAddress): UnprovenOutput;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): UnprovenOutput;
  toString(compact?: boolean): string;
  /**
   * The commitment of the output
   */
  readonly commitment: CoinCommitment;
  /**
   * The contract address receiving the output, if the recipient is a contract
   */
  readonly contractAddress: ContractAddress | undefined;
}

/**
 * An {@link Output} with all proof information erased
 *
 * Primarily for use in testing, or handling data known to be correct from
 * external information
 */
export class ProofErasedOutput {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): ProofErasedOutput;
  toString(compact?: boolean): string;
  /**
   * The commitment of the output
   */
  readonly commitment: CoinCommitment;
  /**
   * The contract address receiving the output, if the recipient is a contract
   */
  readonly contractAddress: ContractAddress | undefined;
}

/**
 * A shielded "transient"; an output that is immediately spent within the same
 * transaction
 */
export class Transient {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): Transient;
  toString(compact?: boolean): string;
  /**
   * The commitment of the transient
   */
  readonly commitment: CoinCommitment;
  /**
   * The contract address creating the transient, if applicable
   */
  readonly contractAddress: ContractAddress | undefined;
  /**
   * The nullifier of the transient
   */
  readonly nullifier: Nullifier;
}

/**
 * A {@link Transient}, before being proven
 *
 * All "shielded" information in the transient can still be extracted at this
 * stage!
 */
export class UnprovenTransient {
  private constructor();
  /**
   * Creates a new contract-owned transient, from a given output and its coin.
   *
   * The {@link QualifiedCoinInfo} should have an `mt_index` of `0`
   */
  static newFromContractOwnedOutput(coin: QualifiedCoinInfo, segment: number, output: UnprovenOutput): UnprovenTransient;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): UnprovenTransient;
  toString(compact?: boolean): string;
  /**
   * The commitment of the transient
   */
  readonly commitment: CoinCommitment;
  /**
   * The contract address creating the transient, if applicable
   */
  readonly contractAddress: ContractAddress | undefined;
  /**
   * The nullifier of the transient
   */
  readonly nullifier: Nullifier;
}

/**
 * A {@link Transient}, with all proof information erased
 *
 * Primarily for use in testing, or handling data known to be correct from
 * external information
 */
export class ProofErasedTransient {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): ProofErasedTransient;
  toString(compact?: boolean): string;
  /**
   * The commitment of the transient
   */
  readonly commitment: CoinCommitment;
  /**
   * The contract address creating the transient, if applicable
   */
  readonly contractAddress: ContractAddress | undefined;
  /**
   * The nullifier of the transient
   */
  readonly nullifier: Nullifier;
}

/**
 * A request to mint a coin, authorized by the mint's recipient
 */
export class AuthorizedMint {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): AuthorizedMint;
  erase_proof(): ProofErasedAuthorizedMint;
  /**
   * The coin to be minted
   */
  readonly coin: CoinInfo;
  /**
   * The recipient of this mint
   */
  readonly recipient: string;
  toString(compact?: boolean): string;
}

/**
 * A request to mint a coin, authorized by the mint's recipient, without the
 * proof for the authorization being generated
 */
export class UnprovenAuthorizedMint {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): UnprovenAuthorizedMint;
  erase_proof(): ProofErasedAuthorizedMint;
  /**
   * The coin to be minted
   */
  readonly coin: CoinInfo;
  /**
   * The recipient of this mint
   */
  readonly recipient: string;
  toString(compact?: boolean): string;
}

/**
 * A request to mint a coin, authorized by the mint's recipient, with the
 * authorizing proof having been erased
 */
export class ProofErasedAuthorizedMint {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): ProofErasedAuthorizedMint;
  /**
   * The coin to be minted
   */
  readonly coin: CoinInfo;
  /**
   * The recipient of this mint
   */
  readonly recipient: string;
  toString(compact?: boolean): string;
}

/**
 * A full Zswap offer; the zswap part of a transaction
 *
 * Consists of sets of {@link Input}s, {@link Output}s, and {@link Transient}s,
 * as well as a {@link deltas} vector of the transaction value
 */
export class Offer {
  private constructor();
  /**
   * Combine this offer with another
   */
  merge(other: Offer): Offer;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): Offer;
  toString(compact?: boolean): string;
  /**
   * The value of this offer for each token type; note that this may be
   * negative
   *
   * This is input coin values - output coin values, for value vectors
   */
  readonly deltas: Map<TokenType, bigint>;
  /**
   * The inputs this offer is composed of
   */
  readonly inputs: Input[];
  /**
   * The outputs this offer is composed of
   */
  readonly outputs: Output[];
  /**
   * The transients this offer is composed of
   */
  readonly transient: Transient[];
}

/**
 * A {@link Offer}, prior to being proven
 *
 * All "shielded" information in the offer can still be extracted at this
 * stage!
 */
export class UnprovenOffer {
  constructor();
  /**
   * Creates a singleton offer, from an {@link UnprovenInput} and its value
   * vector
   */
  static fromInput(input: UnprovenInput, type_: TokenType, value: bigint): UnprovenOffer;
  /**
   * Creates a singleton offer, from an {@link UnprovenOutput} and its value
   * vector
   */
  static fromOutput(output: UnprovenOutput, type_: TokenType, value: bigint): UnprovenOffer;
  /**
   * Creates a singleton offer, from an {@link UnprovenTransient}
   */
  static fromTransient(transient: UnprovenTransient): UnprovenOffer;
  /**
   * Combine this offer with another
   */
  merge(other: UnprovenOffer): UnprovenOffer;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): UnprovenOffer;
  toString(compact?: boolean): string;
  /**
   * The value of this offer for each token type; note that this may be
   * negative
   *
   * This is input coin values - output coin values, for value vectors
   */
  readonly deltas: Map<TokenType, bigint>;
  /**
   * The inputs this offer is composed of
   */
  readonly inputs: UnprovenInput[];
  /**
   * The outputs this offer is composed of
   */
  readonly outputs: UnprovenOutput[];
  /**
   * The transients this offer is composed of
   */
  readonly transient: UnprovenTransient[];
}

/**
 * An {@link Offer}, with all proof information erased
 *
 * Primarily for use in testing, or handling data known to be correct from
 * external information
 */
export class ProofErasedOffer {
  private constructor();
  merge(other: ProofErasedOffer): ProofErasedOffer;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): ProofErasedOffer;
  toString(compact?: boolean): string;
  /**
   * The value of this offer for each token type; note that this may be
   * negative
   *
   * This is input coin values - output coin values, for value vectors
   */
  readonly deltas: Map<TokenType, bigint>;
  /**
   * The inputs this offer is composed of
   */
  readonly inputs: ProofErasedInput[];
  /**
   * The outputs this offer is composed of
   */
  readonly outputs: ProofErasedOutput[];
  /**
   * The transients this offer is composed of
   */
  readonly transient: ProofErasedTransient[];
}

/**
 * A priviledged transaction issued by the system.
 */
export class SystemTransaction {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): Transaction;
  toString(compact?: boolean): string;
}
