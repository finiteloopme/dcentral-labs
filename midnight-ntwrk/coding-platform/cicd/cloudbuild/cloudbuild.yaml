# Cloud Build configuration for Terraform deployment
# This file orchestrates infrastructure deployment using Cloud Build

# Substitutions can be provided via triggers or command line
substitutions:
  _TERRAFORM_VERSION: '1.9.8'
  _ENVIRONMENT: 'dev'
  _TERRAFORM_ACTION: 'apply'  # Can be: plan, apply, destroy
  _AUTO_APPROVE: 'false'
  _REGION: 'us-central1'
  _ZONE: 'us-central1-a'

options:
  logging: CLOUD_LOGGING_ONLY
  substitutionOption: 'ALLOW_LOOSE'
  machineType: 'E2_HIGHCPU_8'

# Use user-managed service account for Cloud Build
serviceAccount: 'projects/${PROJECT_ID}/serviceAccounts/midnight-cloudbuild-sa@${PROJECT_ID}.iam.gserviceaccount.com'

# Build steps
steps:
  # Step 1: Initialize Terraform with GCS backend
  - id: 'terraform-init'
    name: 'hashicorp/terraform:${_TERRAFORM_VERSION}'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        cd terraform
        echo "Initializing Terraform with GCS backend..."
        terraform init \
          -backend-config="bucket=${PROJECT_ID}-terraform-state" \
          -backend-config="prefix=midnight-platform/${_ENVIRONMENT}" \
          -input=false

  # Step 2: Validate Terraform configuration
  - id: 'terraform-validate'
    name: 'hashicorp/terraform:${_TERRAFORM_VERSION}'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        cd terraform
        echo "Validating Terraform configuration..."
        terraform validate || { echo "Validation failed!"; exit 1; }
        echo "Validation passed!"
        echo "Checking formatting..."
        terraform fmt -check=true -diff || { echo "Format check failed! Run 'terraform fmt' to fix."; exit 1; }
        echo "Format check passed!"

  # Step 3: Select workspace based on environment
  - id: 'terraform-workspace'
    name: 'hashicorp/terraform:${_TERRAFORM_VERSION}'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        cd terraform
        echo "Selecting workspace: ${_ENVIRONMENT}"
        terraform workspace select ${_ENVIRONMENT} || terraform workspace new ${_ENVIRONMENT}

  # Step 4: Plan Terraform changes
  - id: 'terraform-plan'
    name: 'hashicorp/terraform:${_TERRAFORM_VERSION}'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        cd terraform
        echo "Planning Terraform changes..."
        terraform plan \
          -var="project_id=${PROJECT_ID}" \
          -var="environment=${_ENVIRONMENT}" \
          -var="region=${_REGION}" \
          -var="zone=${_ZONE}" \
          -out=tfplan.binary \
          -input=false
        
        # Convert to JSON for review
        terraform show -json tfplan.binary > tfplan.json
        
        # Create human-readable plan
        terraform show tfplan.binary > tfplan.txt
        
        echo "Plan complete. Review tfplan.txt for changes."

  # Step 5: Apply Terraform changes (conditional)
  - id: 'terraform-apply'
    name: 'hashicorp/terraform:${_TERRAFORM_VERSION}'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        cd terraform
        
        # Only run apply if _TERRAFORM_ACTION is 'apply'
        if [ "${_TERRAFORM_ACTION}" = "apply" ]; then
          echo "Applying Terraform changes..."
          
          if [ "${_AUTO_APPROVE}" = "true" ]; then
            terraform apply tfplan.binary
          else
            echo "Auto-approve is disabled. Run with _AUTO_APPROVE=true to apply."
            exit 1
          fi
          
          # Save outputs
          terraform output -json > outputs.json
          echo "Deployment complete!"
        else
          echo "Skipping apply. Set _TERRAFORM_ACTION=apply to deploy."
        fi

  # Step 6: Build and push container image (if infrastructure is ready)
  - id: 'build-container'
    name: 'gcr.io/cloud-builders/docker'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        # Only build if we're applying changes
        if [ "${_TERRAFORM_ACTION}" = "apply" ] && [ "${_AUTO_APPROVE}" = "true" ]; then
          echo "Building container image..."
          # Build from docker directory with its own context
          # The Dockerfile is now self-contained and doesn't need parent directory context
          docker build -t ${_REGION}-docker.pkg.dev/${PROJECT_ID}/midnight-${_ENVIRONMENT}-workstation-images/workstation:${BUILD_ID} docker/
          docker build -t ${_REGION}-docker.pkg.dev/${PROJECT_ID}/midnight-${_ENVIRONMENT}-workstation-images/workstation:latest docker/
        else
          echo "Skipping container build."
        fi

  # Step 7: Push container to Artifact Registry
  - id: 'push-container'
    name: 'gcr.io/cloud-builders/docker'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        # Only push if we built the container
        if [ "${_TERRAFORM_ACTION}" = "apply" ] && [ "${_AUTO_APPROVE}" = "true" ]; then
          echo "Pushing container to Artifact Registry..."
          docker push ${_REGION}-docker.pkg.dev/${PROJECT_ID}/midnight-${_ENVIRONMENT}-workstation-images/workstation:${BUILD_ID}
          docker push ${_REGION}-docker.pkg.dev/${PROJECT_ID}/midnight-${_ENVIRONMENT}-workstation-images/workstation:latest
        else
          echo "Skipping container push."
        fi

# Store artifacts
artifacts:
  objects:
    location: 'gs://${PROJECT_ID}-terraform-state/builds/${BUILD_ID}'
    paths:
      - 'terraform/tfplan.txt'
      - 'terraform/tfplan.json'
      - 'terraform/outputs.json'

# Set timeout for the entire build
timeout: '1800s'

# Tags for organizing builds
tags:
  - 'terraform'
  - 'infrastructure'
  - 'midnight-platform'
  - '${_ENVIRONMENT}'